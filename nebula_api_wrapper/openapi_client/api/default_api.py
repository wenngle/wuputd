# coding: utf-8

"""
    nebula-api

    The public Nebula Labs API for access to pertinent UT Dallas data

    The version of the OpenAPI document: 1.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictFloat, StrictInt, StrictStr
from typing import Optional, Union
from typing_extensions import Annotated
from openapi_client.models.schema_api_response_array_int import SchemaAPIResponseArrayInt
from openapi_client.models.schema_api_response_array_schema_autocomplete import SchemaAPIResponseArraySchemaAutocomplete
from openapi_client.models.schema_api_response_array_schema_building_rooms import SchemaAPIResponseArraySchemaBuildingRooms
from openapi_client.models.schema_api_response_array_schema_course import SchemaAPIResponseArraySchemaCourse
from openapi_client.models.schema_api_response_array_schema_grade_data import SchemaAPIResponseArraySchemaGradeData
from openapi_client.models.schema_api_response_array_schema_professor import SchemaAPIResponseArraySchemaProfessor
from openapi_client.models.schema_api_response_array_schema_section import SchemaAPIResponseArraySchemaSection
from openapi_client.models.schema_api_response_array_schema_typed_grade_data import SchemaAPIResponseArraySchemaTypedGradeData
from openapi_client.models.schema_api_response_int import SchemaAPIResponseInt
from openapi_client.models.schema_api_response_schema_bucket_info import SchemaAPIResponseSchemaBucketInfo
from openapi_client.models.schema_api_response_schema_course import SchemaAPIResponseSchemaCourse
from openapi_client.models.schema_api_response_schema_multi_building_events_schema_astra_event import SchemaAPIResponseSchemaMultiBuildingEventsSchemaAstraEvent
from openapi_client.models.schema_api_response_schema_multi_building_events_schema_mazevo_event import SchemaAPIResponseSchemaMultiBuildingEventsSchemaMazevoEvent
from openapi_client.models.schema_api_response_schema_multi_building_events_schema_section_with_time import SchemaAPIResponseSchemaMultiBuildingEventsSchemaSectionWithTime
from openapi_client.models.schema_api_response_schema_object_info import SchemaAPIResponseSchemaObjectInfo
from openapi_client.models.schema_api_response_schema_professor import SchemaAPIResponseSchemaProfessor
from openapi_client.models.schema_api_response_schema_section import SchemaAPIResponseSchemaSection
from openapi_client.models.schema_api_response_schema_single_building_events_schema_section_with_time import SchemaAPIResponseSchemaSingleBuildingEventsSchemaSectionWithTime

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class DefaultApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def astra_events(
        self,
        var_date: Annotated[StrictStr, Field(description="date (ISO format) to retrieve astra events")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseSchemaMultiBuildingEventsSchemaAstraEvent:
        """astra_events

        \"Returns AstraEvent based on the input date\"

        :param var_date: date (ISO format) to retrieve astra events (required)
        :type var_date: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._astra_events_serialize(
            var_date=var_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaMultiBuildingEventsSchemaAstraEvent",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def astra_events_with_http_info(
        self,
        var_date: Annotated[StrictStr, Field(description="date (ISO format) to retrieve astra events")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseSchemaMultiBuildingEventsSchemaAstraEvent]:
        """astra_events

        \"Returns AstraEvent based on the input date\"

        :param var_date: date (ISO format) to retrieve astra events (required)
        :type var_date: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._astra_events_serialize(
            var_date=var_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaMultiBuildingEventsSchemaAstraEvent",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def astra_events_without_preload_content(
        self,
        var_date: Annotated[StrictStr, Field(description="date (ISO format) to retrieve astra events")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """astra_events

        \"Returns AstraEvent based on the input date\"

        :param var_date: date (ISO format) to retrieve astra events (required)
        :type var_date: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._astra_events_serialize(
            var_date=var_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaMultiBuildingEventsSchemaAstraEvent",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _astra_events_serialize(
        self,
        var_date,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if var_date is not None:
            _path_params['date'] = var_date
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/astra/{date}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def autocomplete_dag(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseArraySchemaAutocomplete:
        """autocomplete_dag

        \"Returns an aggregation of courses for use in generating autocomplete DAGs\"

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._autocomplete_dag_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaAutocomplete",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def autocomplete_dag_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseArraySchemaAutocomplete]:
        """autocomplete_dag

        \"Returns an aggregation of courses for use in generating autocomplete DAGs\"

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._autocomplete_dag_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaAutocomplete",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def autocomplete_dag_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """autocomplete_dag

        \"Returns an aggregation of courses for use in generating autocomplete DAGs\"

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._autocomplete_dag_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaAutocomplete",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _autocomplete_dag_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/autocomplete/dag',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def bucket_info(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket")],
        x_storage_key: Annotated[StrictStr, Field(description="The internal storage key")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseSchemaBucketInfo:
        """bucket_info

        \"Get info on a bucket. This route is restricted to only Nebula Labs internal Projects.\"

        :param bucket: Name of the bucket (required)
        :type bucket: str
        :param x_storage_key: The internal storage key (required)
        :type x_storage_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bucket_info_serialize(
            bucket=bucket,
            x_storage_key=x_storage_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaBucketInfo",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def bucket_info_with_http_info(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket")],
        x_storage_key: Annotated[StrictStr, Field(description="The internal storage key")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseSchemaBucketInfo]:
        """bucket_info

        \"Get info on a bucket. This route is restricted to only Nebula Labs internal Projects.\"

        :param bucket: Name of the bucket (required)
        :type bucket: str
        :param x_storage_key: The internal storage key (required)
        :type x_storage_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bucket_info_serialize(
            bucket=bucket,
            x_storage_key=x_storage_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaBucketInfo",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def bucket_info_without_preload_content(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket")],
        x_storage_key: Annotated[StrictStr, Field(description="The internal storage key")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """bucket_info

        \"Get info on a bucket. This route is restricted to only Nebula Labs internal Projects.\"

        :param bucket: Name of the bucket (required)
        :type bucket: str
        :param x_storage_key: The internal storage key (required)
        :type x_storage_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bucket_info_serialize(
            bucket=bucket,
            x_storage_key=x_storage_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaBucketInfo",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _bucket_info_serialize(
        self,
        bucket,
        x_storage_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if bucket is not None:
            _path_params['bucket'] = bucket
        # process the query parameters
        # process the header parameters
        if x_storage_key is not None:
            _header_params['x-storage-key'] = x_storage_key
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/storage/{bucket}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def course_all(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseArraySchemaCourse:
        """course_all

        \"Returns all courses\"

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._course_all_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaCourse",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def course_all_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseArraySchemaCourse]:
        """course_all

        \"Returns all courses\"

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._course_all_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaCourse",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def course_all_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """course_all

        \"Returns all courses\"

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._course_all_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaCourse",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _course_all_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/course/all',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def course_by_id(
        self,
        id: Annotated[StrictStr, Field(description="ID of the course to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseSchemaCourse:
        """course_by_id

        \"Returns the course with given ID\"

        :param id: ID of the course to get (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._course_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaCourse",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def course_by_id_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="ID of the course to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseSchemaCourse]:
        """course_by_id

        \"Returns the course with given ID\"

        :param id: ID of the course to get (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._course_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaCourse",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def course_by_id_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="ID of the course to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """course_by_id

        \"Returns the course with given ID\"

        :param id: ID of the course to get (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._course_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaCourse",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _course_by_id_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/course/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def course_search(
        self,
        offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of courses (e.g. For starting at the 17th course, offset=16).")] = None,
        course_number: Annotated[Optional[StrictStr], Field(description="The course's official number")] = None,
        subject_prefix: Annotated[Optional[StrictStr], Field(description="The course's subject prefix")] = None,
        title: Annotated[Optional[StrictStr], Field(description="The course's title")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The course's description")] = None,
        school: Annotated[Optional[StrictStr], Field(description="The course's school")] = None,
        credit_hours: Annotated[Optional[StrictStr], Field(description="The number of credit hours awarded by successful completion of the course")] = None,
        class_level: Annotated[Optional[StrictStr], Field(description="The level of education that this course course corresponds to")] = None,
        activity_type: Annotated[Optional[StrictStr], Field(description="The type of class this course corresponds to")] = None,
        grading: Annotated[Optional[StrictStr], Field(description="The grading status of this course")] = None,
        internal_course_number: Annotated[Optional[StrictStr], Field(description="The internal (university) number used to reference this course")] = None,
        lecture_contact_hours: Annotated[Optional[StrictStr], Field(description="The weekly contact hours in lecture for a course")] = None,
        offering_frequency: Annotated[Optional[StrictStr], Field(description="The frequency of offering a course")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseArraySchemaCourse:
        """course_search

        \"Returns paginated list of courses matching the query's string-typed key-value pairs. See offset for more details on pagination.\"

        :param offset: The starting position of the current page of courses (e.g. For starting at the 17th course, offset=16).
        :type offset: float
        :param course_number: The course's official number
        :type course_number: str
        :param subject_prefix: The course's subject prefix
        :type subject_prefix: str
        :param title: The course's title
        :type title: str
        :param description: The course's description
        :type description: str
        :param school: The course's school
        :type school: str
        :param credit_hours: The number of credit hours awarded by successful completion of the course
        :type credit_hours: str
        :param class_level: The level of education that this course course corresponds to
        :type class_level: str
        :param activity_type: The type of class this course corresponds to
        :type activity_type: str
        :param grading: The grading status of this course
        :type grading: str
        :param internal_course_number: The internal (university) number used to reference this course
        :type internal_course_number: str
        :param lecture_contact_hours: The weekly contact hours in lecture for a course
        :type lecture_contact_hours: str
        :param offering_frequency: The frequency of offering a course
        :type offering_frequency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._course_search_serialize(
            offset=offset,
            course_number=course_number,
            subject_prefix=subject_prefix,
            title=title,
            description=description,
            school=school,
            credit_hours=credit_hours,
            class_level=class_level,
            activity_type=activity_type,
            grading=grading,
            internal_course_number=internal_course_number,
            lecture_contact_hours=lecture_contact_hours,
            offering_frequency=offering_frequency,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaCourse",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def course_search_with_http_info(
        self,
        offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of courses (e.g. For starting at the 17th course, offset=16).")] = None,
        course_number: Annotated[Optional[StrictStr], Field(description="The course's official number")] = None,
        subject_prefix: Annotated[Optional[StrictStr], Field(description="The course's subject prefix")] = None,
        title: Annotated[Optional[StrictStr], Field(description="The course's title")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The course's description")] = None,
        school: Annotated[Optional[StrictStr], Field(description="The course's school")] = None,
        credit_hours: Annotated[Optional[StrictStr], Field(description="The number of credit hours awarded by successful completion of the course")] = None,
        class_level: Annotated[Optional[StrictStr], Field(description="The level of education that this course course corresponds to")] = None,
        activity_type: Annotated[Optional[StrictStr], Field(description="The type of class this course corresponds to")] = None,
        grading: Annotated[Optional[StrictStr], Field(description="The grading status of this course")] = None,
        internal_course_number: Annotated[Optional[StrictStr], Field(description="The internal (university) number used to reference this course")] = None,
        lecture_contact_hours: Annotated[Optional[StrictStr], Field(description="The weekly contact hours in lecture for a course")] = None,
        offering_frequency: Annotated[Optional[StrictStr], Field(description="The frequency of offering a course")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseArraySchemaCourse]:
        """course_search

        \"Returns paginated list of courses matching the query's string-typed key-value pairs. See offset for more details on pagination.\"

        :param offset: The starting position of the current page of courses (e.g. For starting at the 17th course, offset=16).
        :type offset: float
        :param course_number: The course's official number
        :type course_number: str
        :param subject_prefix: The course's subject prefix
        :type subject_prefix: str
        :param title: The course's title
        :type title: str
        :param description: The course's description
        :type description: str
        :param school: The course's school
        :type school: str
        :param credit_hours: The number of credit hours awarded by successful completion of the course
        :type credit_hours: str
        :param class_level: The level of education that this course course corresponds to
        :type class_level: str
        :param activity_type: The type of class this course corresponds to
        :type activity_type: str
        :param grading: The grading status of this course
        :type grading: str
        :param internal_course_number: The internal (university) number used to reference this course
        :type internal_course_number: str
        :param lecture_contact_hours: The weekly contact hours in lecture for a course
        :type lecture_contact_hours: str
        :param offering_frequency: The frequency of offering a course
        :type offering_frequency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._course_search_serialize(
            offset=offset,
            course_number=course_number,
            subject_prefix=subject_prefix,
            title=title,
            description=description,
            school=school,
            credit_hours=credit_hours,
            class_level=class_level,
            activity_type=activity_type,
            grading=grading,
            internal_course_number=internal_course_number,
            lecture_contact_hours=lecture_contact_hours,
            offering_frequency=offering_frequency,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaCourse",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def course_search_without_preload_content(
        self,
        offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of courses (e.g. For starting at the 17th course, offset=16).")] = None,
        course_number: Annotated[Optional[StrictStr], Field(description="The course's official number")] = None,
        subject_prefix: Annotated[Optional[StrictStr], Field(description="The course's subject prefix")] = None,
        title: Annotated[Optional[StrictStr], Field(description="The course's title")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The course's description")] = None,
        school: Annotated[Optional[StrictStr], Field(description="The course's school")] = None,
        credit_hours: Annotated[Optional[StrictStr], Field(description="The number of credit hours awarded by successful completion of the course")] = None,
        class_level: Annotated[Optional[StrictStr], Field(description="The level of education that this course course corresponds to")] = None,
        activity_type: Annotated[Optional[StrictStr], Field(description="The type of class this course corresponds to")] = None,
        grading: Annotated[Optional[StrictStr], Field(description="The grading status of this course")] = None,
        internal_course_number: Annotated[Optional[StrictStr], Field(description="The internal (university) number used to reference this course")] = None,
        lecture_contact_hours: Annotated[Optional[StrictStr], Field(description="The weekly contact hours in lecture for a course")] = None,
        offering_frequency: Annotated[Optional[StrictStr], Field(description="The frequency of offering a course")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """course_search

        \"Returns paginated list of courses matching the query's string-typed key-value pairs. See offset for more details on pagination.\"

        :param offset: The starting position of the current page of courses (e.g. For starting at the 17th course, offset=16).
        :type offset: float
        :param course_number: The course's official number
        :type course_number: str
        :param subject_prefix: The course's subject prefix
        :type subject_prefix: str
        :param title: The course's title
        :type title: str
        :param description: The course's description
        :type description: str
        :param school: The course's school
        :type school: str
        :param credit_hours: The number of credit hours awarded by successful completion of the course
        :type credit_hours: str
        :param class_level: The level of education that this course course corresponds to
        :type class_level: str
        :param activity_type: The type of class this course corresponds to
        :type activity_type: str
        :param grading: The grading status of this course
        :type grading: str
        :param internal_course_number: The internal (university) number used to reference this course
        :type internal_course_number: str
        :param lecture_contact_hours: The weekly contact hours in lecture for a course
        :type lecture_contact_hours: str
        :param offering_frequency: The frequency of offering a course
        :type offering_frequency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._course_search_serialize(
            offset=offset,
            course_number=course_number,
            subject_prefix=subject_prefix,
            title=title,
            description=description,
            school=school,
            credit_hours=credit_hours,
            class_level=class_level,
            activity_type=activity_type,
            grading=grading,
            internal_course_number=internal_course_number,
            lecture_contact_hours=lecture_contact_hours,
            offering_frequency=offering_frequency,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaCourse",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _course_search_serialize(
        self,
        offset,
        course_number,
        subject_prefix,
        title,
        description,
        school,
        credit_hours,
        class_level,
        activity_type,
        grading,
        internal_course_number,
        lecture_contact_hours,
        offering_frequency,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if course_number is not None:
            
            _query_params.append(('course_number', course_number))
            
        if subject_prefix is not None:
            
            _query_params.append(('subject_prefix', subject_prefix))
            
        if title is not None:
            
            _query_params.append(('title', title))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if school is not None:
            
            _query_params.append(('school', school))
            
        if credit_hours is not None:
            
            _query_params.append(('credit_hours', credit_hours))
            
        if class_level is not None:
            
            _query_params.append(('class_level', class_level))
            
        if activity_type is not None:
            
            _query_params.append(('activity_type', activity_type))
            
        if grading is not None:
            
            _query_params.append(('grading', grading))
            
        if internal_course_number is not None:
            
            _query_params.append(('internal_course_number', internal_course_number))
            
        if lecture_contact_hours is not None:
            
            _query_params.append(('lecture_contact_hours', lecture_contact_hours))
            
        if offering_frequency is not None:
            
            _query_params.append(('offering_frequency', offering_frequency))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/course',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def course_section_by_id(
        self,
        id: Annotated[StrictStr, Field(description="ID of the course to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseArraySchemaSection:
        """course_section_by_id

        \"Returns the all of the sections of the course with given ID\"

        :param id: ID of the course to get (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._course_section_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaSection",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def course_section_by_id_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="ID of the course to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseArraySchemaSection]:
        """course_section_by_id

        \"Returns the all of the sections of the course with given ID\"

        :param id: ID of the course to get (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._course_section_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaSection",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def course_section_by_id_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="ID of the course to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """course_section_by_id

        \"Returns the all of the sections of the course with given ID\"

        :param id: ID of the course to get (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._course_section_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaSection",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _course_section_by_id_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/course/{id}/sections',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def course_section_search(
        self,
        former_offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of courses (e.g. For starting at the 17th course, former_offset=16).")] = None,
        latter_offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of sections (e.g. For starting at the 4th section, latter_offset=3).")] = None,
        course_number: Annotated[Optional[StrictStr], Field(description="The course's official number")] = None,
        subject_prefix: Annotated[Optional[StrictStr], Field(description="The course's subject prefix")] = None,
        title: Annotated[Optional[StrictStr], Field(description="The course's title")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The course's description")] = None,
        school: Annotated[Optional[StrictStr], Field(description="The course's school")] = None,
        credit_hours: Annotated[Optional[StrictStr], Field(description="The number of credit hours awarded by successful completion of the course")] = None,
        class_level: Annotated[Optional[StrictStr], Field(description="The level of education that this course course corresponds to")] = None,
        activity_type: Annotated[Optional[StrictStr], Field(description="The type of class this course corresponds to")] = None,
        grading: Annotated[Optional[StrictStr], Field(description="The grading status of this course")] = None,
        internal_course_number: Annotated[Optional[StrictStr], Field(description="The internal (university) number used to reference this course")] = None,
        lecture_contact_hours: Annotated[Optional[StrictStr], Field(description="The weekly contact hours in lecture for a course")] = None,
        offering_frequency: Annotated[Optional[StrictStr], Field(description="The frequency of offering a course")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseArraySchemaSection:
        """course_section_search

        \"Returns paginated list of sections of all the courses matching the query's string-typed key-value pairs. See former_offset and latter_offset for pagination details.\"

        :param former_offset: The starting position of the current page of courses (e.g. For starting at the 17th course, former_offset=16).
        :type former_offset: float
        :param latter_offset: The starting position of the current page of sections (e.g. For starting at the 4th section, latter_offset=3).
        :type latter_offset: float
        :param course_number: The course's official number
        :type course_number: str
        :param subject_prefix: The course's subject prefix
        :type subject_prefix: str
        :param title: The course's title
        :type title: str
        :param description: The course's description
        :type description: str
        :param school: The course's school
        :type school: str
        :param credit_hours: The number of credit hours awarded by successful completion of the course
        :type credit_hours: str
        :param class_level: The level of education that this course course corresponds to
        :type class_level: str
        :param activity_type: The type of class this course corresponds to
        :type activity_type: str
        :param grading: The grading status of this course
        :type grading: str
        :param internal_course_number: The internal (university) number used to reference this course
        :type internal_course_number: str
        :param lecture_contact_hours: The weekly contact hours in lecture for a course
        :type lecture_contact_hours: str
        :param offering_frequency: The frequency of offering a course
        :type offering_frequency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._course_section_search_serialize(
            former_offset=former_offset,
            latter_offset=latter_offset,
            course_number=course_number,
            subject_prefix=subject_prefix,
            title=title,
            description=description,
            school=school,
            credit_hours=credit_hours,
            class_level=class_level,
            activity_type=activity_type,
            grading=grading,
            internal_course_number=internal_course_number,
            lecture_contact_hours=lecture_contact_hours,
            offering_frequency=offering_frequency,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaSection",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def course_section_search_with_http_info(
        self,
        former_offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of courses (e.g. For starting at the 17th course, former_offset=16).")] = None,
        latter_offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of sections (e.g. For starting at the 4th section, latter_offset=3).")] = None,
        course_number: Annotated[Optional[StrictStr], Field(description="The course's official number")] = None,
        subject_prefix: Annotated[Optional[StrictStr], Field(description="The course's subject prefix")] = None,
        title: Annotated[Optional[StrictStr], Field(description="The course's title")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The course's description")] = None,
        school: Annotated[Optional[StrictStr], Field(description="The course's school")] = None,
        credit_hours: Annotated[Optional[StrictStr], Field(description="The number of credit hours awarded by successful completion of the course")] = None,
        class_level: Annotated[Optional[StrictStr], Field(description="The level of education that this course course corresponds to")] = None,
        activity_type: Annotated[Optional[StrictStr], Field(description="The type of class this course corresponds to")] = None,
        grading: Annotated[Optional[StrictStr], Field(description="The grading status of this course")] = None,
        internal_course_number: Annotated[Optional[StrictStr], Field(description="The internal (university) number used to reference this course")] = None,
        lecture_contact_hours: Annotated[Optional[StrictStr], Field(description="The weekly contact hours in lecture for a course")] = None,
        offering_frequency: Annotated[Optional[StrictStr], Field(description="The frequency of offering a course")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseArraySchemaSection]:
        """course_section_search

        \"Returns paginated list of sections of all the courses matching the query's string-typed key-value pairs. See former_offset and latter_offset for pagination details.\"

        :param former_offset: The starting position of the current page of courses (e.g. For starting at the 17th course, former_offset=16).
        :type former_offset: float
        :param latter_offset: The starting position of the current page of sections (e.g. For starting at the 4th section, latter_offset=3).
        :type latter_offset: float
        :param course_number: The course's official number
        :type course_number: str
        :param subject_prefix: The course's subject prefix
        :type subject_prefix: str
        :param title: The course's title
        :type title: str
        :param description: The course's description
        :type description: str
        :param school: The course's school
        :type school: str
        :param credit_hours: The number of credit hours awarded by successful completion of the course
        :type credit_hours: str
        :param class_level: The level of education that this course course corresponds to
        :type class_level: str
        :param activity_type: The type of class this course corresponds to
        :type activity_type: str
        :param grading: The grading status of this course
        :type grading: str
        :param internal_course_number: The internal (university) number used to reference this course
        :type internal_course_number: str
        :param lecture_contact_hours: The weekly contact hours in lecture for a course
        :type lecture_contact_hours: str
        :param offering_frequency: The frequency of offering a course
        :type offering_frequency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._course_section_search_serialize(
            former_offset=former_offset,
            latter_offset=latter_offset,
            course_number=course_number,
            subject_prefix=subject_prefix,
            title=title,
            description=description,
            school=school,
            credit_hours=credit_hours,
            class_level=class_level,
            activity_type=activity_type,
            grading=grading,
            internal_course_number=internal_course_number,
            lecture_contact_hours=lecture_contact_hours,
            offering_frequency=offering_frequency,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaSection",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def course_section_search_without_preload_content(
        self,
        former_offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of courses (e.g. For starting at the 17th course, former_offset=16).")] = None,
        latter_offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of sections (e.g. For starting at the 4th section, latter_offset=3).")] = None,
        course_number: Annotated[Optional[StrictStr], Field(description="The course's official number")] = None,
        subject_prefix: Annotated[Optional[StrictStr], Field(description="The course's subject prefix")] = None,
        title: Annotated[Optional[StrictStr], Field(description="The course's title")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The course's description")] = None,
        school: Annotated[Optional[StrictStr], Field(description="The course's school")] = None,
        credit_hours: Annotated[Optional[StrictStr], Field(description="The number of credit hours awarded by successful completion of the course")] = None,
        class_level: Annotated[Optional[StrictStr], Field(description="The level of education that this course course corresponds to")] = None,
        activity_type: Annotated[Optional[StrictStr], Field(description="The type of class this course corresponds to")] = None,
        grading: Annotated[Optional[StrictStr], Field(description="The grading status of this course")] = None,
        internal_course_number: Annotated[Optional[StrictStr], Field(description="The internal (university) number used to reference this course")] = None,
        lecture_contact_hours: Annotated[Optional[StrictStr], Field(description="The weekly contact hours in lecture for a course")] = None,
        offering_frequency: Annotated[Optional[StrictStr], Field(description="The frequency of offering a course")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """course_section_search

        \"Returns paginated list of sections of all the courses matching the query's string-typed key-value pairs. See former_offset and latter_offset for pagination details.\"

        :param former_offset: The starting position of the current page of courses (e.g. For starting at the 17th course, former_offset=16).
        :type former_offset: float
        :param latter_offset: The starting position of the current page of sections (e.g. For starting at the 4th section, latter_offset=3).
        :type latter_offset: float
        :param course_number: The course's official number
        :type course_number: str
        :param subject_prefix: The course's subject prefix
        :type subject_prefix: str
        :param title: The course's title
        :type title: str
        :param description: The course's description
        :type description: str
        :param school: The course's school
        :type school: str
        :param credit_hours: The number of credit hours awarded by successful completion of the course
        :type credit_hours: str
        :param class_level: The level of education that this course course corresponds to
        :type class_level: str
        :param activity_type: The type of class this course corresponds to
        :type activity_type: str
        :param grading: The grading status of this course
        :type grading: str
        :param internal_course_number: The internal (university) number used to reference this course
        :type internal_course_number: str
        :param lecture_contact_hours: The weekly contact hours in lecture for a course
        :type lecture_contact_hours: str
        :param offering_frequency: The frequency of offering a course
        :type offering_frequency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._course_section_search_serialize(
            former_offset=former_offset,
            latter_offset=latter_offset,
            course_number=course_number,
            subject_prefix=subject_prefix,
            title=title,
            description=description,
            school=school,
            credit_hours=credit_hours,
            class_level=class_level,
            activity_type=activity_type,
            grading=grading,
            internal_course_number=internal_course_number,
            lecture_contact_hours=lecture_contact_hours,
            offering_frequency=offering_frequency,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaSection",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _course_section_search_serialize(
        self,
        former_offset,
        latter_offset,
        course_number,
        subject_prefix,
        title,
        description,
        school,
        credit_hours,
        class_level,
        activity_type,
        grading,
        internal_course_number,
        lecture_contact_hours,
        offering_frequency,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if former_offset is not None:
            
            _query_params.append(('former_offset', former_offset))
            
        if latter_offset is not None:
            
            _query_params.append(('latter_offset', latter_offset))
            
        if course_number is not None:
            
            _query_params.append(('course_number', course_number))
            
        if subject_prefix is not None:
            
            _query_params.append(('subject_prefix', subject_prefix))
            
        if title is not None:
            
            _query_params.append(('title', title))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if school is not None:
            
            _query_params.append(('school', school))
            
        if credit_hours is not None:
            
            _query_params.append(('credit_hours', credit_hours))
            
        if class_level is not None:
            
            _query_params.append(('class_level', class_level))
            
        if activity_type is not None:
            
            _query_params.append(('activity_type', activity_type))
            
        if grading is not None:
            
            _query_params.append(('grading', grading))
            
        if internal_course_number is not None:
            
            _query_params.append(('internal_course_number', internal_course_number))
            
        if lecture_contact_hours is not None:
            
            _query_params.append(('lecture_contact_hours', lecture_contact_hours))
            
        if offering_frequency is not None:
            
            _query_params.append(('offering_frequency', offering_frequency))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/course/sections',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_bucket(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket")],
        x_storage_key: Annotated[StrictStr, Field(description="The internal storage key")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseInt:
        """delete_bucket

        \"Delete a bucket. This route is restricted to only Nebula Labs internal Projects.\"

        :param bucket: Name of the bucket (required)
        :type bucket: str
        :param x_storage_key: The internal storage key (required)
        :type x_storage_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_bucket_serialize(
            bucket=bucket,
            x_storage_key=x_storage_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseInt",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_bucket_with_http_info(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket")],
        x_storage_key: Annotated[StrictStr, Field(description="The internal storage key")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseInt]:
        """delete_bucket

        \"Delete a bucket. This route is restricted to only Nebula Labs internal Projects.\"

        :param bucket: Name of the bucket (required)
        :type bucket: str
        :param x_storage_key: The internal storage key (required)
        :type x_storage_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_bucket_serialize(
            bucket=bucket,
            x_storage_key=x_storage_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseInt",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_bucket_without_preload_content(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket")],
        x_storage_key: Annotated[StrictStr, Field(description="The internal storage key")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_bucket

        \"Delete a bucket. This route is restricted to only Nebula Labs internal Projects.\"

        :param bucket: Name of the bucket (required)
        :type bucket: str
        :param x_storage_key: The internal storage key (required)
        :type x_storage_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_bucket_serialize(
            bucket=bucket,
            x_storage_key=x_storage_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseInt",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_bucket_serialize(
        self,
        bucket,
        x_storage_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if bucket is not None:
            _path_params['bucket'] = bucket
        # process the query parameters
        # process the header parameters
        if x_storage_key is not None:
            _header_params['x-storage-key'] = x_storage_key
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/storage/{bucket}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_object(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket")],
        object_id: Annotated[StrictStr, Field(description="ID of the object")],
        x_storage_key: Annotated[StrictStr, Field(description="The internal storage key")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseInt:
        """delete_object

        \"Delete an object from a bucket. This route is restricted to only Nebula Labs internal Projects.\"

        :param bucket: Name of the bucket (required)
        :type bucket: str
        :param object_id: ID of the object (required)
        :type object_id: str
        :param x_storage_key: The internal storage key (required)
        :type x_storage_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_object_serialize(
            bucket=bucket,
            object_id=object_id,
            x_storage_key=x_storage_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseInt",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_object_with_http_info(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket")],
        object_id: Annotated[StrictStr, Field(description="ID of the object")],
        x_storage_key: Annotated[StrictStr, Field(description="The internal storage key")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseInt]:
        """delete_object

        \"Delete an object from a bucket. This route is restricted to only Nebula Labs internal Projects.\"

        :param bucket: Name of the bucket (required)
        :type bucket: str
        :param object_id: ID of the object (required)
        :type object_id: str
        :param x_storage_key: The internal storage key (required)
        :type x_storage_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_object_serialize(
            bucket=bucket,
            object_id=object_id,
            x_storage_key=x_storage_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseInt",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_object_without_preload_content(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket")],
        object_id: Annotated[StrictStr, Field(description="ID of the object")],
        x_storage_key: Annotated[StrictStr, Field(description="The internal storage key")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_object

        \"Delete an object from a bucket. This route is restricted to only Nebula Labs internal Projects.\"

        :param bucket: Name of the bucket (required)
        :type bucket: str
        :param object_id: ID of the object (required)
        :type object_id: str
        :param x_storage_key: The internal storage key (required)
        :type x_storage_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_object_serialize(
            bucket=bucket,
            object_id=object_id,
            x_storage_key=x_storage_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseInt",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_object_serialize(
        self,
        bucket,
        object_id,
        x_storage_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if bucket is not None:
            _path_params['bucket'] = bucket
        if object_id is not None:
            _path_params['objectID'] = object_id
        # process the query parameters
        # process the header parameters
        if x_storage_key is not None:
            _header_params['x-storage-key'] = x_storage_key
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/storage/{bucket}/{objectID}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def events(
        self,
        var_date: Annotated[StrictStr, Field(description="ISO date of the set of events to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseSchemaMultiBuildingEventsSchemaSectionWithTime:
        """events

        \"Returns all sections with meetings on the specified date\"

        :param var_date: ISO date of the set of events to get (required)
        :type var_date: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._events_serialize(
            var_date=var_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaMultiBuildingEventsSchemaSectionWithTime",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def events_with_http_info(
        self,
        var_date: Annotated[StrictStr, Field(description="ISO date of the set of events to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseSchemaMultiBuildingEventsSchemaSectionWithTime]:
        """events

        \"Returns all sections with meetings on the specified date\"

        :param var_date: ISO date of the set of events to get (required)
        :type var_date: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._events_serialize(
            var_date=var_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaMultiBuildingEventsSchemaSectionWithTime",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def events_without_preload_content(
        self,
        var_date: Annotated[StrictStr, Field(description="ISO date of the set of events to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """events

        \"Returns all sections with meetings on the specified date\"

        :param var_date: ISO date of the set of events to get (required)
        :type var_date: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._events_serialize(
            var_date=var_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaMultiBuildingEventsSchemaSectionWithTime",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _events_serialize(
        self,
        var_date,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if var_date is not None:
            _path_params['date'] = var_date
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/events/{date}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def events_by_building(
        self,
        var_date: Annotated[StrictStr, Field(description="ISO date of the set of events to get")],
        building: Annotated[StrictStr, Field(description="building abbreviation of event locations")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseSchemaSingleBuildingEventsSchemaSectionWithTime:
        """events_by_building

        \"Returns all sections with meetings on the specified date in the specified building\"

        :param var_date: ISO date of the set of events to get (required)
        :type var_date: str
        :param building: building abbreviation of event locations (required)
        :type building: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._events_by_building_serialize(
            var_date=var_date,
            building=building,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaSingleBuildingEventsSchemaSectionWithTime",
            '404': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def events_by_building_with_http_info(
        self,
        var_date: Annotated[StrictStr, Field(description="ISO date of the set of events to get")],
        building: Annotated[StrictStr, Field(description="building abbreviation of event locations")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseSchemaSingleBuildingEventsSchemaSectionWithTime]:
        """events_by_building

        \"Returns all sections with meetings on the specified date in the specified building\"

        :param var_date: ISO date of the set of events to get (required)
        :type var_date: str
        :param building: building abbreviation of event locations (required)
        :type building: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._events_by_building_serialize(
            var_date=var_date,
            building=building,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaSingleBuildingEventsSchemaSectionWithTime",
            '404': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def events_by_building_without_preload_content(
        self,
        var_date: Annotated[StrictStr, Field(description="ISO date of the set of events to get")],
        building: Annotated[StrictStr, Field(description="building abbreviation of event locations")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """events_by_building

        \"Returns all sections with meetings on the specified date in the specified building\"

        :param var_date: ISO date of the set of events to get (required)
        :type var_date: str
        :param building: building abbreviation of event locations (required)
        :type building: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._events_by_building_serialize(
            var_date=var_date,
            building=building,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaSingleBuildingEventsSchemaSectionWithTime",
            '404': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _events_by_building_serialize(
        self,
        var_date,
        building,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if var_date is not None:
            _path_params['date'] = var_date
        if building is not None:
            _path_params['building'] = building
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/events/{date}/{building}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def grade_aggregation_by_semester(
        self,
        prefix: Annotated[Optional[StrictStr], Field(description="The course's subject prefix")] = None,
        number: Annotated[Optional[StrictStr], Field(description="The course's official number")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="The professor's first name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="The professors's last name")] = None,
        section_number: Annotated[Optional[StrictStr], Field(description="The number of the section")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseArraySchemaGradeData:
        """grade_aggregation_by_semester

        \"Returns grade distributions aggregated by semester\"

        :param prefix: The course's subject prefix
        :type prefix: str
        :param number: The course's official number
        :type number: str
        :param first_name: The professor's first name
        :type first_name: str
        :param last_name: The professors's last name
        :type last_name: str
        :param section_number: The number of the section
        :type section_number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._grade_aggregation_by_semester_serialize(
            prefix=prefix,
            number=number,
            first_name=first_name,
            last_name=last_name,
            section_number=section_number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaGradeData",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def grade_aggregation_by_semester_with_http_info(
        self,
        prefix: Annotated[Optional[StrictStr], Field(description="The course's subject prefix")] = None,
        number: Annotated[Optional[StrictStr], Field(description="The course's official number")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="The professor's first name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="The professors's last name")] = None,
        section_number: Annotated[Optional[StrictStr], Field(description="The number of the section")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseArraySchemaGradeData]:
        """grade_aggregation_by_semester

        \"Returns grade distributions aggregated by semester\"

        :param prefix: The course's subject prefix
        :type prefix: str
        :param number: The course's official number
        :type number: str
        :param first_name: The professor's first name
        :type first_name: str
        :param last_name: The professors's last name
        :type last_name: str
        :param section_number: The number of the section
        :type section_number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._grade_aggregation_by_semester_serialize(
            prefix=prefix,
            number=number,
            first_name=first_name,
            last_name=last_name,
            section_number=section_number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaGradeData",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def grade_aggregation_by_semester_without_preload_content(
        self,
        prefix: Annotated[Optional[StrictStr], Field(description="The course's subject prefix")] = None,
        number: Annotated[Optional[StrictStr], Field(description="The course's official number")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="The professor's first name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="The professors's last name")] = None,
        section_number: Annotated[Optional[StrictStr], Field(description="The number of the section")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """grade_aggregation_by_semester

        \"Returns grade distributions aggregated by semester\"

        :param prefix: The course's subject prefix
        :type prefix: str
        :param number: The course's official number
        :type number: str
        :param first_name: The professor's first name
        :type first_name: str
        :param last_name: The professors's last name
        :type last_name: str
        :param section_number: The number of the section
        :type section_number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._grade_aggregation_by_semester_serialize(
            prefix=prefix,
            number=number,
            first_name=first_name,
            last_name=last_name,
            section_number=section_number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaGradeData",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _grade_aggregation_by_semester_serialize(
        self,
        prefix,
        number,
        first_name,
        last_name,
        section_number,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if prefix is not None:
            
            _query_params.append(('prefix', prefix))
            
        if number is not None:
            
            _query_params.append(('number', number))
            
        if first_name is not None:
            
            _query_params.append(('first_name', first_name))
            
        if last_name is not None:
            
            _query_params.append(('last_name', last_name))
            
        if section_number is not None:
            
            _query_params.append(('section_number', section_number))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/grades/semester',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def grade_aggregation_overall(
        self,
        prefix: Annotated[Optional[StrictStr], Field(description="The course's subject prefix")] = None,
        number: Annotated[Optional[StrictStr], Field(description="The course's official number")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="The professor's first name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="The professors's last name")] = None,
        section_number: Annotated[Optional[StrictStr], Field(description="The number of the section")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseArrayInt:
        """grade_aggregation_overall

        \"Returns the overall grade distribution\"

        :param prefix: The course's subject prefix
        :type prefix: str
        :param number: The course's official number
        :type number: str
        :param first_name: The professor's first name
        :type first_name: str
        :param last_name: The professors's last name
        :type last_name: str
        :param section_number: The number of the section
        :type section_number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._grade_aggregation_overall_serialize(
            prefix=prefix,
            number=number,
            first_name=first_name,
            last_name=last_name,
            section_number=section_number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArrayInt",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def grade_aggregation_overall_with_http_info(
        self,
        prefix: Annotated[Optional[StrictStr], Field(description="The course's subject prefix")] = None,
        number: Annotated[Optional[StrictStr], Field(description="The course's official number")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="The professor's first name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="The professors's last name")] = None,
        section_number: Annotated[Optional[StrictStr], Field(description="The number of the section")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseArrayInt]:
        """grade_aggregation_overall

        \"Returns the overall grade distribution\"

        :param prefix: The course's subject prefix
        :type prefix: str
        :param number: The course's official number
        :type number: str
        :param first_name: The professor's first name
        :type first_name: str
        :param last_name: The professors's last name
        :type last_name: str
        :param section_number: The number of the section
        :type section_number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._grade_aggregation_overall_serialize(
            prefix=prefix,
            number=number,
            first_name=first_name,
            last_name=last_name,
            section_number=section_number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArrayInt",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def grade_aggregation_overall_without_preload_content(
        self,
        prefix: Annotated[Optional[StrictStr], Field(description="The course's subject prefix")] = None,
        number: Annotated[Optional[StrictStr], Field(description="The course's official number")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="The professor's first name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="The professors's last name")] = None,
        section_number: Annotated[Optional[StrictStr], Field(description="The number of the section")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """grade_aggregation_overall

        \"Returns the overall grade distribution\"

        :param prefix: The course's subject prefix
        :type prefix: str
        :param number: The course's official number
        :type number: str
        :param first_name: The professor's first name
        :type first_name: str
        :param last_name: The professors's last name
        :type last_name: str
        :param section_number: The number of the section
        :type section_number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._grade_aggregation_overall_serialize(
            prefix=prefix,
            number=number,
            first_name=first_name,
            last_name=last_name,
            section_number=section_number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArrayInt",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _grade_aggregation_overall_serialize(
        self,
        prefix,
        number,
        first_name,
        last_name,
        section_number,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if prefix is not None:
            
            _query_params.append(('prefix', prefix))
            
        if number is not None:
            
            _query_params.append(('number', number))
            
        if first_name is not None:
            
            _query_params.append(('first_name', first_name))
            
        if last_name is not None:
            
            _query_params.append(('last_name', last_name))
            
        if section_number is not None:
            
            _query_params.append(('section_number', section_number))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/grades/overall',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def grade_aggregation_section_type(
        self,
        prefix: Annotated[Optional[StrictStr], Field(description="The course's subject prefix")] = None,
        number: Annotated[Optional[StrictStr], Field(description="The course's official number")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="The professor's first name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="The professors's last name")] = None,
        section_number: Annotated[Optional[StrictStr], Field(description="The number of the section")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseArraySchemaTypedGradeData:
        """grade_aggregation_section_type

        \"Returns the grade distributions aggregated by semester and broken down into section type\"

        :param prefix: The course's subject prefix
        :type prefix: str
        :param number: The course's official number
        :type number: str
        :param first_name: The professor's first name
        :type first_name: str
        :param last_name: The professors's last name
        :type last_name: str
        :param section_number: The number of the section
        :type section_number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._grade_aggregation_section_type_serialize(
            prefix=prefix,
            number=number,
            first_name=first_name,
            last_name=last_name,
            section_number=section_number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaTypedGradeData",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def grade_aggregation_section_type_with_http_info(
        self,
        prefix: Annotated[Optional[StrictStr], Field(description="The course's subject prefix")] = None,
        number: Annotated[Optional[StrictStr], Field(description="The course's official number")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="The professor's first name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="The professors's last name")] = None,
        section_number: Annotated[Optional[StrictStr], Field(description="The number of the section")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseArraySchemaTypedGradeData]:
        """grade_aggregation_section_type

        \"Returns the grade distributions aggregated by semester and broken down into section type\"

        :param prefix: The course's subject prefix
        :type prefix: str
        :param number: The course's official number
        :type number: str
        :param first_name: The professor's first name
        :type first_name: str
        :param last_name: The professors's last name
        :type last_name: str
        :param section_number: The number of the section
        :type section_number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._grade_aggregation_section_type_serialize(
            prefix=prefix,
            number=number,
            first_name=first_name,
            last_name=last_name,
            section_number=section_number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaTypedGradeData",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def grade_aggregation_section_type_without_preload_content(
        self,
        prefix: Annotated[Optional[StrictStr], Field(description="The course's subject prefix")] = None,
        number: Annotated[Optional[StrictStr], Field(description="The course's official number")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="The professor's first name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="The professors's last name")] = None,
        section_number: Annotated[Optional[StrictStr], Field(description="The number of the section")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """grade_aggregation_section_type

        \"Returns the grade distributions aggregated by semester and broken down into section type\"

        :param prefix: The course's subject prefix
        :type prefix: str
        :param number: The course's official number
        :type number: str
        :param first_name: The professor's first name
        :type first_name: str
        :param last_name: The professors's last name
        :type last_name: str
        :param section_number: The number of the section
        :type section_number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._grade_aggregation_section_type_serialize(
            prefix=prefix,
            number=number,
            first_name=first_name,
            last_name=last_name,
            section_number=section_number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaTypedGradeData",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _grade_aggregation_section_type_serialize(
        self,
        prefix,
        number,
        first_name,
        last_name,
        section_number,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if prefix is not None:
            
            _query_params.append(('prefix', prefix))
            
        if number is not None:
            
            _query_params.append(('number', number))
            
        if first_name is not None:
            
            _query_params.append(('first_name', first_name))
            
        if last_name is not None:
            
            _query_params.append(('last_name', last_name))
            
        if section_number is not None:
            
            _query_params.append(('section_number', section_number))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/grades/semester/sectionType',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def grades_by_course_id(
        self,
        id: Annotated[StrictStr, Field(description="ID of course to get grades for")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseArrayInt:
        """grades_by_course_id

        \"Returns the overall grade distribution for a course\"

        :param id: ID of course to get grades for (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._grades_by_course_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArrayInt",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def grades_by_course_id_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="ID of course to get grades for")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseArrayInt]:
        """grades_by_course_id

        \"Returns the overall grade distribution for a course\"

        :param id: ID of course to get grades for (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._grades_by_course_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArrayInt",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def grades_by_course_id_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="ID of course to get grades for")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """grades_by_course_id

        \"Returns the overall grade distribution for a course\"

        :param id: ID of course to get grades for (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._grades_by_course_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArrayInt",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _grades_by_course_id_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/course/{id}/grades',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def grades_by_professor_id(
        self,
        id: Annotated[StrictStr, Field(description="ID of professor to get grades for")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseArrayInt:
        """grades_by_professor_id

        \"Returns the overall grade distribution for a professor\"

        :param id: ID of professor to get grades for (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._grades_by_professor_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArrayInt",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def grades_by_professor_id_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="ID of professor to get grades for")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseArrayInt]:
        """grades_by_professor_id

        \"Returns the overall grade distribution for a professor\"

        :param id: ID of professor to get grades for (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._grades_by_professor_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArrayInt",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def grades_by_professor_id_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="ID of professor to get grades for")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """grades_by_professor_id

        \"Returns the overall grade distribution for a professor\"

        :param id: ID of professor to get grades for (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._grades_by_professor_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArrayInt",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _grades_by_professor_id_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/professor/{id}/grades',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def grades_by_section_id(
        self,
        id: Annotated[StrictStr, Field(description="ID of section to get grades for")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseArrayInt:
        """grades_by_section_id

        \"Returns the overall grade distribution for a section\"

        :param id: ID of section to get grades for (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._grades_by_section_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArrayInt",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def grades_by_section_id_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="ID of section to get grades for")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseArrayInt]:
        """grades_by_section_id

        \"Returns the overall grade distribution for a section\"

        :param id: ID of section to get grades for (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._grades_by_section_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArrayInt",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def grades_by_section_id_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="ID of section to get grades for")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """grades_by_section_id

        \"Returns the overall grade distribution for a section\"

        :param id: ID of section to get grades for (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._grades_by_section_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArrayInt",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _grades_by_section_id_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/section/{id}/grades',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def mazevo_events(
        self,
        var_date: Annotated[StrictStr, Field(description="date (ISO format) to retrieve mazevo events")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseSchemaMultiBuildingEventsSchemaMazevoEvent:
        """mazevo_events

        \"Returns MazevoEvent based on the input date\"

        :param var_date: date (ISO format) to retrieve mazevo events (required)
        :type var_date: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._mazevo_events_serialize(
            var_date=var_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaMultiBuildingEventsSchemaMazevoEvent",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def mazevo_events_with_http_info(
        self,
        var_date: Annotated[StrictStr, Field(description="date (ISO format) to retrieve mazevo events")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseSchemaMultiBuildingEventsSchemaMazevoEvent]:
        """mazevo_events

        \"Returns MazevoEvent based on the input date\"

        :param var_date: date (ISO format) to retrieve mazevo events (required)
        :type var_date: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._mazevo_events_serialize(
            var_date=var_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaMultiBuildingEventsSchemaMazevoEvent",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def mazevo_events_without_preload_content(
        self,
        var_date: Annotated[StrictStr, Field(description="date (ISO format) to retrieve mazevo events")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """mazevo_events

        \"Returns MazevoEvent based on the input date\"

        :param var_date: date (ISO format) to retrieve mazevo events (required)
        :type var_date: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._mazevo_events_serialize(
            var_date=var_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaMultiBuildingEventsSchemaMazevoEvent",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _mazevo_events_serialize(
        self,
        var_date,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if var_date is not None:
            _path_params['date'] = var_date
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/mazevo/{date}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def object_info(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket")],
        object_id: Annotated[StrictStr, Field(description="ID of the object")],
        x_storage_key: Annotated[StrictStr, Field(description="The internal storage key")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseSchemaObjectInfo:
        """object_info

        \"Get info on an object in a bucket. This route is restricted to only Nebula Labs internal Projects.\"

        :param bucket: Name of the bucket (required)
        :type bucket: str
        :param object_id: ID of the object (required)
        :type object_id: str
        :param x_storage_key: The internal storage key (required)
        :type x_storage_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._object_info_serialize(
            bucket=bucket,
            object_id=object_id,
            x_storage_key=x_storage_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaObjectInfo",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def object_info_with_http_info(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket")],
        object_id: Annotated[StrictStr, Field(description="ID of the object")],
        x_storage_key: Annotated[StrictStr, Field(description="The internal storage key")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseSchemaObjectInfo]:
        """object_info

        \"Get info on an object in a bucket. This route is restricted to only Nebula Labs internal Projects.\"

        :param bucket: Name of the bucket (required)
        :type bucket: str
        :param object_id: ID of the object (required)
        :type object_id: str
        :param x_storage_key: The internal storage key (required)
        :type x_storage_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._object_info_serialize(
            bucket=bucket,
            object_id=object_id,
            x_storage_key=x_storage_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaObjectInfo",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def object_info_without_preload_content(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket")],
        object_id: Annotated[StrictStr, Field(description="ID of the object")],
        x_storage_key: Annotated[StrictStr, Field(description="The internal storage key")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """object_info

        \"Get info on an object in a bucket. This route is restricted to only Nebula Labs internal Projects.\"

        :param bucket: Name of the bucket (required)
        :type bucket: str
        :param object_id: ID of the object (required)
        :type object_id: str
        :param x_storage_key: The internal storage key (required)
        :type x_storage_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._object_info_serialize(
            bucket=bucket,
            object_id=object_id,
            x_storage_key=x_storage_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaObjectInfo",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _object_info_serialize(
        self,
        bucket,
        object_id,
        x_storage_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if bucket is not None:
            _path_params['bucket'] = bucket
        if object_id is not None:
            _path_params['objectID'] = object_id
        # process the query parameters
        # process the header parameters
        if x_storage_key is not None:
            _header_params['x-storage-key'] = x_storage_key
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/storage/{bucket}/{objectID}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_object(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket")],
        object_id: Annotated[StrictStr, Field(description="ID of the object")],
        x_storage_key: Annotated[StrictStr, Field(description="The internal storage key")],
        data: Annotated[StrictStr, Field(description="The data to upload")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseSchemaObjectInfo:
        """post_object

        \"Upload an object to a bucket. This route is restricted to only Nebula Labs internal Projects.\"

        :param bucket: Name of the bucket (required)
        :type bucket: str
        :param object_id: ID of the object (required)
        :type object_id: str
        :param x_storage_key: The internal storage key (required)
        :type x_storage_key: str
        :param data: The data to upload (required)
        :type data: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_object_serialize(
            bucket=bucket,
            object_id=object_id,
            x_storage_key=x_storage_key,
            data=data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaObjectInfo",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_object_with_http_info(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket")],
        object_id: Annotated[StrictStr, Field(description="ID of the object")],
        x_storage_key: Annotated[StrictStr, Field(description="The internal storage key")],
        data: Annotated[StrictStr, Field(description="The data to upload")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseSchemaObjectInfo]:
        """post_object

        \"Upload an object to a bucket. This route is restricted to only Nebula Labs internal Projects.\"

        :param bucket: Name of the bucket (required)
        :type bucket: str
        :param object_id: ID of the object (required)
        :type object_id: str
        :param x_storage_key: The internal storage key (required)
        :type x_storage_key: str
        :param data: The data to upload (required)
        :type data: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_object_serialize(
            bucket=bucket,
            object_id=object_id,
            x_storage_key=x_storage_key,
            data=data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaObjectInfo",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_object_without_preload_content(
        self,
        bucket: Annotated[StrictStr, Field(description="Name of the bucket")],
        object_id: Annotated[StrictStr, Field(description="ID of the object")],
        x_storage_key: Annotated[StrictStr, Field(description="The internal storage key")],
        data: Annotated[StrictStr, Field(description="The data to upload")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """post_object

        \"Upload an object to a bucket. This route is restricted to only Nebula Labs internal Projects.\"

        :param bucket: Name of the bucket (required)
        :type bucket: str
        :param object_id: ID of the object (required)
        :type object_id: str
        :param x_storage_key: The internal storage key (required)
        :type x_storage_key: str
        :param data: The data to upload (required)
        :type data: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_object_serialize(
            bucket=bucket,
            object_id=object_id,
            x_storage_key=x_storage_key,
            data=data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaObjectInfo",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_object_serialize(
        self,
        bucket,
        object_id,
        x_storage_key,
        data,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if bucket is not None:
            _path_params['bucket'] = bucket
        if object_id is not None:
            _path_params['objectID'] = object_id
        # process the query parameters
        # process the header parameters
        if x_storage_key is not None:
            _header_params['x-storage-key'] = x_storage_key
        # process the form parameters
        # process the body parameter
        if data is not None:
            _body_params = data


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/storage/{bucket}/{objectID}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def professor_all(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseArraySchemaProfessor:
        """professor_all

        \"Returns all professors\"

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._professor_all_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaProfessor",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def professor_all_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseArraySchemaProfessor]:
        """professor_all

        \"Returns all professors\"

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._professor_all_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaProfessor",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def professor_all_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """professor_all

        \"Returns all professors\"

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._professor_all_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaProfessor",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _professor_all_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/professor/all',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def professor_by_id(
        self,
        id: Annotated[StrictStr, Field(description="ID of the professor to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseSchemaProfessor:
        """professor_by_id

        \"Returns the professor with given ID\"

        :param id: ID of the professor to get (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._professor_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaProfessor",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def professor_by_id_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="ID of the professor to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseSchemaProfessor]:
        """professor_by_id

        \"Returns the professor with given ID\"

        :param id: ID of the professor to get (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._professor_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaProfessor",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def professor_by_id_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="ID of the professor to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """professor_by_id

        \"Returns the professor with given ID\"

        :param id: ID of the professor to get (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._professor_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaProfessor",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _professor_by_id_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/professor/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def professor_course_by_id(
        self,
        id: Annotated[StrictStr, Field(description="ID of the professor to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseArraySchemaCourse:
        """professor_course_by_id

        \"Returns all the courses taught by the professor with given ID\"

        :param id: ID of the professor to get (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._professor_course_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaCourse",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def professor_course_by_id_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="ID of the professor to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseArraySchemaCourse]:
        """professor_course_by_id

        \"Returns all the courses taught by the professor with given ID\"

        :param id: ID of the professor to get (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._professor_course_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaCourse",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def professor_course_by_id_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="ID of the professor to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """professor_course_by_id

        \"Returns all the courses taught by the professor with given ID\"

        :param id: ID of the professor to get (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._professor_course_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaCourse",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _professor_course_by_id_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/professor/{id}/courses',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def professor_course_search(
        self,
        former_offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of professors (e.g. For starting at the 17th professor, former_offset=16).")] = None,
        latter_offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of courses (e.g. For starting at the 4th course, latter_offset=3).")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="The professor's first name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="The professor's last name")] = None,
        titles: Annotated[Optional[StrictStr], Field(description="One of the professor's title")] = None,
        email: Annotated[Optional[StrictStr], Field(description="The professor's email address")] = None,
        phone_number: Annotated[Optional[StrictStr], Field(description="The professor's phone number")] = None,
        office_building: Annotated[Optional[StrictStr], Field(description="The building of the location of the professor's office")] = None,
        office_room: Annotated[Optional[StrictStr], Field(description="The room of the location of the professor's office")] = None,
        office_map_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink to the UTD room locator of the professor's office")] = None,
        profile_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink pointing to the professor's official university profile")] = None,
        image_uri: Annotated[Optional[StrictStr], Field(description="A link to the image used for the professor on the professor's official university profile")] = None,
        office_hours_start_date: Annotated[Optional[StrictStr], Field(description="The start date of one of the office hours meetings of the professor")] = None,
        office_hours_end_date: Annotated[Optional[StrictStr], Field(description="The end date of one of the office hours meetings of the professor")] = None,
        office_hours_meeting_days: Annotated[Optional[StrictStr], Field(description="One of the days that one of the office hours meetings of the professor")] = None,
        office_hours_start_time: Annotated[Optional[StrictStr], Field(description="The time one of the office hours meetings of the professor starts")] = None,
        office_hours_end_time: Annotated[Optional[StrictStr], Field(description="The time one of the office hours meetings of the professor ends")] = None,
        office_hours_modality: Annotated[Optional[StrictStr], Field(description="The modality of one of the office hours meetings of the professor")] = None,
        office_hours_location_building: Annotated[Optional[StrictStr], Field(description="The building of one of the office hours meetings of the professor")] = None,
        office_hours_location_room: Annotated[Optional[StrictStr], Field(description="The room of one of the office hours meetings of the professor")] = None,
        office_hours_location_map_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink to the UTD room locator of one of the office hours meetings of the professor")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseArraySchemaProfessor:
        """professor_course_search

        \"Returns paginated list of the courses of all the professors matching the query's string-typed key-value pairs. See former_offset and latter_offset for pagination details.\"

        :param former_offset: The starting position of the current page of professors (e.g. For starting at the 17th professor, former_offset=16).
        :type former_offset: float
        :param latter_offset: The starting position of the current page of courses (e.g. For starting at the 4th course, latter_offset=3).
        :type latter_offset: float
        :param first_name: The professor's first name
        :type first_name: str
        :param last_name: The professor's last name
        :type last_name: str
        :param titles: One of the professor's title
        :type titles: str
        :param email: The professor's email address
        :type email: str
        :param phone_number: The professor's phone number
        :type phone_number: str
        :param office_building: The building of the location of the professor's office
        :type office_building: str
        :param office_room: The room of the location of the professor's office
        :type office_room: str
        :param office_map_uri: A hyperlink to the UTD room locator of the professor's office
        :type office_map_uri: str
        :param profile_uri: A hyperlink pointing to the professor's official university profile
        :type profile_uri: str
        :param image_uri: A link to the image used for the professor on the professor's official university profile
        :type image_uri: str
        :param office_hours_start_date: The start date of one of the office hours meetings of the professor
        :type office_hours_start_date: str
        :param office_hours_end_date: The end date of one of the office hours meetings of the professor
        :type office_hours_end_date: str
        :param office_hours_meeting_days: One of the days that one of the office hours meetings of the professor
        :type office_hours_meeting_days: str
        :param office_hours_start_time: The time one of the office hours meetings of the professor starts
        :type office_hours_start_time: str
        :param office_hours_end_time: The time one of the office hours meetings of the professor ends
        :type office_hours_end_time: str
        :param office_hours_modality: The modality of one of the office hours meetings of the professor
        :type office_hours_modality: str
        :param office_hours_location_building: The building of one of the office hours meetings of the professor
        :type office_hours_location_building: str
        :param office_hours_location_room: The room of one of the office hours meetings of the professor
        :type office_hours_location_room: str
        :param office_hours_location_map_uri: A hyperlink to the UTD room locator of one of the office hours meetings of the professor
        :type office_hours_location_map_uri: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._professor_course_search_serialize(
            former_offset=former_offset,
            latter_offset=latter_offset,
            first_name=first_name,
            last_name=last_name,
            titles=titles,
            email=email,
            phone_number=phone_number,
            office_building=office_building,
            office_room=office_room,
            office_map_uri=office_map_uri,
            profile_uri=profile_uri,
            image_uri=image_uri,
            office_hours_start_date=office_hours_start_date,
            office_hours_end_date=office_hours_end_date,
            office_hours_meeting_days=office_hours_meeting_days,
            office_hours_start_time=office_hours_start_time,
            office_hours_end_time=office_hours_end_time,
            office_hours_modality=office_hours_modality,
            office_hours_location_building=office_hours_location_building,
            office_hours_location_room=office_hours_location_room,
            office_hours_location_map_uri=office_hours_location_map_uri,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaProfessor",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def professor_course_search_with_http_info(
        self,
        former_offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of professors (e.g. For starting at the 17th professor, former_offset=16).")] = None,
        latter_offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of courses (e.g. For starting at the 4th course, latter_offset=3).")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="The professor's first name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="The professor's last name")] = None,
        titles: Annotated[Optional[StrictStr], Field(description="One of the professor's title")] = None,
        email: Annotated[Optional[StrictStr], Field(description="The professor's email address")] = None,
        phone_number: Annotated[Optional[StrictStr], Field(description="The professor's phone number")] = None,
        office_building: Annotated[Optional[StrictStr], Field(description="The building of the location of the professor's office")] = None,
        office_room: Annotated[Optional[StrictStr], Field(description="The room of the location of the professor's office")] = None,
        office_map_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink to the UTD room locator of the professor's office")] = None,
        profile_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink pointing to the professor's official university profile")] = None,
        image_uri: Annotated[Optional[StrictStr], Field(description="A link to the image used for the professor on the professor's official university profile")] = None,
        office_hours_start_date: Annotated[Optional[StrictStr], Field(description="The start date of one of the office hours meetings of the professor")] = None,
        office_hours_end_date: Annotated[Optional[StrictStr], Field(description="The end date of one of the office hours meetings of the professor")] = None,
        office_hours_meeting_days: Annotated[Optional[StrictStr], Field(description="One of the days that one of the office hours meetings of the professor")] = None,
        office_hours_start_time: Annotated[Optional[StrictStr], Field(description="The time one of the office hours meetings of the professor starts")] = None,
        office_hours_end_time: Annotated[Optional[StrictStr], Field(description="The time one of the office hours meetings of the professor ends")] = None,
        office_hours_modality: Annotated[Optional[StrictStr], Field(description="The modality of one of the office hours meetings of the professor")] = None,
        office_hours_location_building: Annotated[Optional[StrictStr], Field(description="The building of one of the office hours meetings of the professor")] = None,
        office_hours_location_room: Annotated[Optional[StrictStr], Field(description="The room of one of the office hours meetings of the professor")] = None,
        office_hours_location_map_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink to the UTD room locator of one of the office hours meetings of the professor")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseArraySchemaProfessor]:
        """professor_course_search

        \"Returns paginated list of the courses of all the professors matching the query's string-typed key-value pairs. See former_offset and latter_offset for pagination details.\"

        :param former_offset: The starting position of the current page of professors (e.g. For starting at the 17th professor, former_offset=16).
        :type former_offset: float
        :param latter_offset: The starting position of the current page of courses (e.g. For starting at the 4th course, latter_offset=3).
        :type latter_offset: float
        :param first_name: The professor's first name
        :type first_name: str
        :param last_name: The professor's last name
        :type last_name: str
        :param titles: One of the professor's title
        :type titles: str
        :param email: The professor's email address
        :type email: str
        :param phone_number: The professor's phone number
        :type phone_number: str
        :param office_building: The building of the location of the professor's office
        :type office_building: str
        :param office_room: The room of the location of the professor's office
        :type office_room: str
        :param office_map_uri: A hyperlink to the UTD room locator of the professor's office
        :type office_map_uri: str
        :param profile_uri: A hyperlink pointing to the professor's official university profile
        :type profile_uri: str
        :param image_uri: A link to the image used for the professor on the professor's official university profile
        :type image_uri: str
        :param office_hours_start_date: The start date of one of the office hours meetings of the professor
        :type office_hours_start_date: str
        :param office_hours_end_date: The end date of one of the office hours meetings of the professor
        :type office_hours_end_date: str
        :param office_hours_meeting_days: One of the days that one of the office hours meetings of the professor
        :type office_hours_meeting_days: str
        :param office_hours_start_time: The time one of the office hours meetings of the professor starts
        :type office_hours_start_time: str
        :param office_hours_end_time: The time one of the office hours meetings of the professor ends
        :type office_hours_end_time: str
        :param office_hours_modality: The modality of one of the office hours meetings of the professor
        :type office_hours_modality: str
        :param office_hours_location_building: The building of one of the office hours meetings of the professor
        :type office_hours_location_building: str
        :param office_hours_location_room: The room of one of the office hours meetings of the professor
        :type office_hours_location_room: str
        :param office_hours_location_map_uri: A hyperlink to the UTD room locator of one of the office hours meetings of the professor
        :type office_hours_location_map_uri: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._professor_course_search_serialize(
            former_offset=former_offset,
            latter_offset=latter_offset,
            first_name=first_name,
            last_name=last_name,
            titles=titles,
            email=email,
            phone_number=phone_number,
            office_building=office_building,
            office_room=office_room,
            office_map_uri=office_map_uri,
            profile_uri=profile_uri,
            image_uri=image_uri,
            office_hours_start_date=office_hours_start_date,
            office_hours_end_date=office_hours_end_date,
            office_hours_meeting_days=office_hours_meeting_days,
            office_hours_start_time=office_hours_start_time,
            office_hours_end_time=office_hours_end_time,
            office_hours_modality=office_hours_modality,
            office_hours_location_building=office_hours_location_building,
            office_hours_location_room=office_hours_location_room,
            office_hours_location_map_uri=office_hours_location_map_uri,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaProfessor",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def professor_course_search_without_preload_content(
        self,
        former_offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of professors (e.g. For starting at the 17th professor, former_offset=16).")] = None,
        latter_offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of courses (e.g. For starting at the 4th course, latter_offset=3).")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="The professor's first name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="The professor's last name")] = None,
        titles: Annotated[Optional[StrictStr], Field(description="One of the professor's title")] = None,
        email: Annotated[Optional[StrictStr], Field(description="The professor's email address")] = None,
        phone_number: Annotated[Optional[StrictStr], Field(description="The professor's phone number")] = None,
        office_building: Annotated[Optional[StrictStr], Field(description="The building of the location of the professor's office")] = None,
        office_room: Annotated[Optional[StrictStr], Field(description="The room of the location of the professor's office")] = None,
        office_map_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink to the UTD room locator of the professor's office")] = None,
        profile_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink pointing to the professor's official university profile")] = None,
        image_uri: Annotated[Optional[StrictStr], Field(description="A link to the image used for the professor on the professor's official university profile")] = None,
        office_hours_start_date: Annotated[Optional[StrictStr], Field(description="The start date of one of the office hours meetings of the professor")] = None,
        office_hours_end_date: Annotated[Optional[StrictStr], Field(description="The end date of one of the office hours meetings of the professor")] = None,
        office_hours_meeting_days: Annotated[Optional[StrictStr], Field(description="One of the days that one of the office hours meetings of the professor")] = None,
        office_hours_start_time: Annotated[Optional[StrictStr], Field(description="The time one of the office hours meetings of the professor starts")] = None,
        office_hours_end_time: Annotated[Optional[StrictStr], Field(description="The time one of the office hours meetings of the professor ends")] = None,
        office_hours_modality: Annotated[Optional[StrictStr], Field(description="The modality of one of the office hours meetings of the professor")] = None,
        office_hours_location_building: Annotated[Optional[StrictStr], Field(description="The building of one of the office hours meetings of the professor")] = None,
        office_hours_location_room: Annotated[Optional[StrictStr], Field(description="The room of one of the office hours meetings of the professor")] = None,
        office_hours_location_map_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink to the UTD room locator of one of the office hours meetings of the professor")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """professor_course_search

        \"Returns paginated list of the courses of all the professors matching the query's string-typed key-value pairs. See former_offset and latter_offset for pagination details.\"

        :param former_offset: The starting position of the current page of professors (e.g. For starting at the 17th professor, former_offset=16).
        :type former_offset: float
        :param latter_offset: The starting position of the current page of courses (e.g. For starting at the 4th course, latter_offset=3).
        :type latter_offset: float
        :param first_name: The professor's first name
        :type first_name: str
        :param last_name: The professor's last name
        :type last_name: str
        :param titles: One of the professor's title
        :type titles: str
        :param email: The professor's email address
        :type email: str
        :param phone_number: The professor's phone number
        :type phone_number: str
        :param office_building: The building of the location of the professor's office
        :type office_building: str
        :param office_room: The room of the location of the professor's office
        :type office_room: str
        :param office_map_uri: A hyperlink to the UTD room locator of the professor's office
        :type office_map_uri: str
        :param profile_uri: A hyperlink pointing to the professor's official university profile
        :type profile_uri: str
        :param image_uri: A link to the image used for the professor on the professor's official university profile
        :type image_uri: str
        :param office_hours_start_date: The start date of one of the office hours meetings of the professor
        :type office_hours_start_date: str
        :param office_hours_end_date: The end date of one of the office hours meetings of the professor
        :type office_hours_end_date: str
        :param office_hours_meeting_days: One of the days that one of the office hours meetings of the professor
        :type office_hours_meeting_days: str
        :param office_hours_start_time: The time one of the office hours meetings of the professor starts
        :type office_hours_start_time: str
        :param office_hours_end_time: The time one of the office hours meetings of the professor ends
        :type office_hours_end_time: str
        :param office_hours_modality: The modality of one of the office hours meetings of the professor
        :type office_hours_modality: str
        :param office_hours_location_building: The building of one of the office hours meetings of the professor
        :type office_hours_location_building: str
        :param office_hours_location_room: The room of one of the office hours meetings of the professor
        :type office_hours_location_room: str
        :param office_hours_location_map_uri: A hyperlink to the UTD room locator of one of the office hours meetings of the professor
        :type office_hours_location_map_uri: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._professor_course_search_serialize(
            former_offset=former_offset,
            latter_offset=latter_offset,
            first_name=first_name,
            last_name=last_name,
            titles=titles,
            email=email,
            phone_number=phone_number,
            office_building=office_building,
            office_room=office_room,
            office_map_uri=office_map_uri,
            profile_uri=profile_uri,
            image_uri=image_uri,
            office_hours_start_date=office_hours_start_date,
            office_hours_end_date=office_hours_end_date,
            office_hours_meeting_days=office_hours_meeting_days,
            office_hours_start_time=office_hours_start_time,
            office_hours_end_time=office_hours_end_time,
            office_hours_modality=office_hours_modality,
            office_hours_location_building=office_hours_location_building,
            office_hours_location_room=office_hours_location_room,
            office_hours_location_map_uri=office_hours_location_map_uri,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaProfessor",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _professor_course_search_serialize(
        self,
        former_offset,
        latter_offset,
        first_name,
        last_name,
        titles,
        email,
        phone_number,
        office_building,
        office_room,
        office_map_uri,
        profile_uri,
        image_uri,
        office_hours_start_date,
        office_hours_end_date,
        office_hours_meeting_days,
        office_hours_start_time,
        office_hours_end_time,
        office_hours_modality,
        office_hours_location_building,
        office_hours_location_room,
        office_hours_location_map_uri,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if former_offset is not None:
            
            _query_params.append(('former_offset', former_offset))
            
        if latter_offset is not None:
            
            _query_params.append(('latter_offset', latter_offset))
            
        if first_name is not None:
            
            _query_params.append(('first_name', first_name))
            
        if last_name is not None:
            
            _query_params.append(('last_name', last_name))
            
        if titles is not None:
            
            _query_params.append(('titles', titles))
            
        if email is not None:
            
            _query_params.append(('email', email))
            
        if phone_number is not None:
            
            _query_params.append(('phone_number', phone_number))
            
        if office_building is not None:
            
            _query_params.append(('office.building', office_building))
            
        if office_room is not None:
            
            _query_params.append(('office.room', office_room))
            
        if office_map_uri is not None:
            
            _query_params.append(('office.map_uri', office_map_uri))
            
        if profile_uri is not None:
            
            _query_params.append(('profile_uri', profile_uri))
            
        if image_uri is not None:
            
            _query_params.append(('image_uri', image_uri))
            
        if office_hours_start_date is not None:
            
            _query_params.append(('office_hours.start_date', office_hours_start_date))
            
        if office_hours_end_date is not None:
            
            _query_params.append(('office_hours.end_date', office_hours_end_date))
            
        if office_hours_meeting_days is not None:
            
            _query_params.append(('office_hours.meeting_days', office_hours_meeting_days))
            
        if office_hours_start_time is not None:
            
            _query_params.append(('office_hours.start_time', office_hours_start_time))
            
        if office_hours_end_time is not None:
            
            _query_params.append(('office_hours.end_time', office_hours_end_time))
            
        if office_hours_modality is not None:
            
            _query_params.append(('office_hours.modality', office_hours_modality))
            
        if office_hours_location_building is not None:
            
            _query_params.append(('office_hours.location.building', office_hours_location_building))
            
        if office_hours_location_room is not None:
            
            _query_params.append(('office_hours.location.room', office_hours_location_room))
            
        if office_hours_location_map_uri is not None:
            
            _query_params.append(('office_hours.location.map_uri', office_hours_location_map_uri))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/professor/courses',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def professor_search(
        self,
        offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of professors (e.g. For starting at the 17th professor, offset=16).")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="The professor's first name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="The professor's last name")] = None,
        titles: Annotated[Optional[StrictStr], Field(description="One of the professor's title")] = None,
        email: Annotated[Optional[StrictStr], Field(description="The professor's email address")] = None,
        phone_number: Annotated[Optional[StrictStr], Field(description="The professor's phone number")] = None,
        office_building: Annotated[Optional[StrictStr], Field(description="The building of the location of the professor's office")] = None,
        office_room: Annotated[Optional[StrictStr], Field(description="The room of the location of the professor's office")] = None,
        office_map_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink to the UTD room locator of the professor's office")] = None,
        profile_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink pointing to the professor's official university profile")] = None,
        image_uri: Annotated[Optional[StrictStr], Field(description="A link to the image used for the professor on the professor's official university profile")] = None,
        office_hours_start_date: Annotated[Optional[StrictStr], Field(description="The start date of one of the office hours meetings of the professor")] = None,
        office_hours_end_date: Annotated[Optional[StrictStr], Field(description="The end date of one of the office hours meetings of the professor")] = None,
        office_hours_meeting_days: Annotated[Optional[StrictStr], Field(description="One of the days that one of the office hours meetings of the professor")] = None,
        office_hours_start_time: Annotated[Optional[StrictStr], Field(description="The time one of the office hours meetings of the professor starts")] = None,
        office_hours_end_time: Annotated[Optional[StrictStr], Field(description="The time one of the office hours meetings of the professor ends")] = None,
        office_hours_modality: Annotated[Optional[StrictStr], Field(description="The modality of one of the office hours meetings of the professor")] = None,
        office_hours_location_building: Annotated[Optional[StrictStr], Field(description="The building of one of the office hours meetings of the professor")] = None,
        office_hours_location_room: Annotated[Optional[StrictStr], Field(description="The room of one of the office hours meetings of the professor")] = None,
        office_hours_location_map_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink to the UTD room locator of one of the office hours meetings of the professor")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseArraySchemaProfessor:
        """professor_search

        \"Returns paginated list of professors matching the query's string-typed key-value pairs. See offset for more details on pagination.\"

        :param offset: The starting position of the current page of professors (e.g. For starting at the 17th professor, offset=16).
        :type offset: float
        :param first_name: The professor's first name
        :type first_name: str
        :param last_name: The professor's last name
        :type last_name: str
        :param titles: One of the professor's title
        :type titles: str
        :param email: The professor's email address
        :type email: str
        :param phone_number: The professor's phone number
        :type phone_number: str
        :param office_building: The building of the location of the professor's office
        :type office_building: str
        :param office_room: The room of the location of the professor's office
        :type office_room: str
        :param office_map_uri: A hyperlink to the UTD room locator of the professor's office
        :type office_map_uri: str
        :param profile_uri: A hyperlink pointing to the professor's official university profile
        :type profile_uri: str
        :param image_uri: A link to the image used for the professor on the professor's official university profile
        :type image_uri: str
        :param office_hours_start_date: The start date of one of the office hours meetings of the professor
        :type office_hours_start_date: str
        :param office_hours_end_date: The end date of one of the office hours meetings of the professor
        :type office_hours_end_date: str
        :param office_hours_meeting_days: One of the days that one of the office hours meetings of the professor
        :type office_hours_meeting_days: str
        :param office_hours_start_time: The time one of the office hours meetings of the professor starts
        :type office_hours_start_time: str
        :param office_hours_end_time: The time one of the office hours meetings of the professor ends
        :type office_hours_end_time: str
        :param office_hours_modality: The modality of one of the office hours meetings of the professor
        :type office_hours_modality: str
        :param office_hours_location_building: The building of one of the office hours meetings of the professor
        :type office_hours_location_building: str
        :param office_hours_location_room: The room of one of the office hours meetings of the professor
        :type office_hours_location_room: str
        :param office_hours_location_map_uri: A hyperlink to the UTD room locator of one of the office hours meetings of the professor
        :type office_hours_location_map_uri: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._professor_search_serialize(
            offset=offset,
            first_name=first_name,
            last_name=last_name,
            titles=titles,
            email=email,
            phone_number=phone_number,
            office_building=office_building,
            office_room=office_room,
            office_map_uri=office_map_uri,
            profile_uri=profile_uri,
            image_uri=image_uri,
            office_hours_start_date=office_hours_start_date,
            office_hours_end_date=office_hours_end_date,
            office_hours_meeting_days=office_hours_meeting_days,
            office_hours_start_time=office_hours_start_time,
            office_hours_end_time=office_hours_end_time,
            office_hours_modality=office_hours_modality,
            office_hours_location_building=office_hours_location_building,
            office_hours_location_room=office_hours_location_room,
            office_hours_location_map_uri=office_hours_location_map_uri,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaProfessor",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def professor_search_with_http_info(
        self,
        offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of professors (e.g. For starting at the 17th professor, offset=16).")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="The professor's first name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="The professor's last name")] = None,
        titles: Annotated[Optional[StrictStr], Field(description="One of the professor's title")] = None,
        email: Annotated[Optional[StrictStr], Field(description="The professor's email address")] = None,
        phone_number: Annotated[Optional[StrictStr], Field(description="The professor's phone number")] = None,
        office_building: Annotated[Optional[StrictStr], Field(description="The building of the location of the professor's office")] = None,
        office_room: Annotated[Optional[StrictStr], Field(description="The room of the location of the professor's office")] = None,
        office_map_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink to the UTD room locator of the professor's office")] = None,
        profile_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink pointing to the professor's official university profile")] = None,
        image_uri: Annotated[Optional[StrictStr], Field(description="A link to the image used for the professor on the professor's official university profile")] = None,
        office_hours_start_date: Annotated[Optional[StrictStr], Field(description="The start date of one of the office hours meetings of the professor")] = None,
        office_hours_end_date: Annotated[Optional[StrictStr], Field(description="The end date of one of the office hours meetings of the professor")] = None,
        office_hours_meeting_days: Annotated[Optional[StrictStr], Field(description="One of the days that one of the office hours meetings of the professor")] = None,
        office_hours_start_time: Annotated[Optional[StrictStr], Field(description="The time one of the office hours meetings of the professor starts")] = None,
        office_hours_end_time: Annotated[Optional[StrictStr], Field(description="The time one of the office hours meetings of the professor ends")] = None,
        office_hours_modality: Annotated[Optional[StrictStr], Field(description="The modality of one of the office hours meetings of the professor")] = None,
        office_hours_location_building: Annotated[Optional[StrictStr], Field(description="The building of one of the office hours meetings of the professor")] = None,
        office_hours_location_room: Annotated[Optional[StrictStr], Field(description="The room of one of the office hours meetings of the professor")] = None,
        office_hours_location_map_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink to the UTD room locator of one of the office hours meetings of the professor")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseArraySchemaProfessor]:
        """professor_search

        \"Returns paginated list of professors matching the query's string-typed key-value pairs. See offset for more details on pagination.\"

        :param offset: The starting position of the current page of professors (e.g. For starting at the 17th professor, offset=16).
        :type offset: float
        :param first_name: The professor's first name
        :type first_name: str
        :param last_name: The professor's last name
        :type last_name: str
        :param titles: One of the professor's title
        :type titles: str
        :param email: The professor's email address
        :type email: str
        :param phone_number: The professor's phone number
        :type phone_number: str
        :param office_building: The building of the location of the professor's office
        :type office_building: str
        :param office_room: The room of the location of the professor's office
        :type office_room: str
        :param office_map_uri: A hyperlink to the UTD room locator of the professor's office
        :type office_map_uri: str
        :param profile_uri: A hyperlink pointing to the professor's official university profile
        :type profile_uri: str
        :param image_uri: A link to the image used for the professor on the professor's official university profile
        :type image_uri: str
        :param office_hours_start_date: The start date of one of the office hours meetings of the professor
        :type office_hours_start_date: str
        :param office_hours_end_date: The end date of one of the office hours meetings of the professor
        :type office_hours_end_date: str
        :param office_hours_meeting_days: One of the days that one of the office hours meetings of the professor
        :type office_hours_meeting_days: str
        :param office_hours_start_time: The time one of the office hours meetings of the professor starts
        :type office_hours_start_time: str
        :param office_hours_end_time: The time one of the office hours meetings of the professor ends
        :type office_hours_end_time: str
        :param office_hours_modality: The modality of one of the office hours meetings of the professor
        :type office_hours_modality: str
        :param office_hours_location_building: The building of one of the office hours meetings of the professor
        :type office_hours_location_building: str
        :param office_hours_location_room: The room of one of the office hours meetings of the professor
        :type office_hours_location_room: str
        :param office_hours_location_map_uri: A hyperlink to the UTD room locator of one of the office hours meetings of the professor
        :type office_hours_location_map_uri: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._professor_search_serialize(
            offset=offset,
            first_name=first_name,
            last_name=last_name,
            titles=titles,
            email=email,
            phone_number=phone_number,
            office_building=office_building,
            office_room=office_room,
            office_map_uri=office_map_uri,
            profile_uri=profile_uri,
            image_uri=image_uri,
            office_hours_start_date=office_hours_start_date,
            office_hours_end_date=office_hours_end_date,
            office_hours_meeting_days=office_hours_meeting_days,
            office_hours_start_time=office_hours_start_time,
            office_hours_end_time=office_hours_end_time,
            office_hours_modality=office_hours_modality,
            office_hours_location_building=office_hours_location_building,
            office_hours_location_room=office_hours_location_room,
            office_hours_location_map_uri=office_hours_location_map_uri,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaProfessor",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def professor_search_without_preload_content(
        self,
        offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of professors (e.g. For starting at the 17th professor, offset=16).")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="The professor's first name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="The professor's last name")] = None,
        titles: Annotated[Optional[StrictStr], Field(description="One of the professor's title")] = None,
        email: Annotated[Optional[StrictStr], Field(description="The professor's email address")] = None,
        phone_number: Annotated[Optional[StrictStr], Field(description="The professor's phone number")] = None,
        office_building: Annotated[Optional[StrictStr], Field(description="The building of the location of the professor's office")] = None,
        office_room: Annotated[Optional[StrictStr], Field(description="The room of the location of the professor's office")] = None,
        office_map_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink to the UTD room locator of the professor's office")] = None,
        profile_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink pointing to the professor's official university profile")] = None,
        image_uri: Annotated[Optional[StrictStr], Field(description="A link to the image used for the professor on the professor's official university profile")] = None,
        office_hours_start_date: Annotated[Optional[StrictStr], Field(description="The start date of one of the office hours meetings of the professor")] = None,
        office_hours_end_date: Annotated[Optional[StrictStr], Field(description="The end date of one of the office hours meetings of the professor")] = None,
        office_hours_meeting_days: Annotated[Optional[StrictStr], Field(description="One of the days that one of the office hours meetings of the professor")] = None,
        office_hours_start_time: Annotated[Optional[StrictStr], Field(description="The time one of the office hours meetings of the professor starts")] = None,
        office_hours_end_time: Annotated[Optional[StrictStr], Field(description="The time one of the office hours meetings of the professor ends")] = None,
        office_hours_modality: Annotated[Optional[StrictStr], Field(description="The modality of one of the office hours meetings of the professor")] = None,
        office_hours_location_building: Annotated[Optional[StrictStr], Field(description="The building of one of the office hours meetings of the professor")] = None,
        office_hours_location_room: Annotated[Optional[StrictStr], Field(description="The room of one of the office hours meetings of the professor")] = None,
        office_hours_location_map_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink to the UTD room locator of one of the office hours meetings of the professor")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """professor_search

        \"Returns paginated list of professors matching the query's string-typed key-value pairs. See offset for more details on pagination.\"

        :param offset: The starting position of the current page of professors (e.g. For starting at the 17th professor, offset=16).
        :type offset: float
        :param first_name: The professor's first name
        :type first_name: str
        :param last_name: The professor's last name
        :type last_name: str
        :param titles: One of the professor's title
        :type titles: str
        :param email: The professor's email address
        :type email: str
        :param phone_number: The professor's phone number
        :type phone_number: str
        :param office_building: The building of the location of the professor's office
        :type office_building: str
        :param office_room: The room of the location of the professor's office
        :type office_room: str
        :param office_map_uri: A hyperlink to the UTD room locator of the professor's office
        :type office_map_uri: str
        :param profile_uri: A hyperlink pointing to the professor's official university profile
        :type profile_uri: str
        :param image_uri: A link to the image used for the professor on the professor's official university profile
        :type image_uri: str
        :param office_hours_start_date: The start date of one of the office hours meetings of the professor
        :type office_hours_start_date: str
        :param office_hours_end_date: The end date of one of the office hours meetings of the professor
        :type office_hours_end_date: str
        :param office_hours_meeting_days: One of the days that one of the office hours meetings of the professor
        :type office_hours_meeting_days: str
        :param office_hours_start_time: The time one of the office hours meetings of the professor starts
        :type office_hours_start_time: str
        :param office_hours_end_time: The time one of the office hours meetings of the professor ends
        :type office_hours_end_time: str
        :param office_hours_modality: The modality of one of the office hours meetings of the professor
        :type office_hours_modality: str
        :param office_hours_location_building: The building of one of the office hours meetings of the professor
        :type office_hours_location_building: str
        :param office_hours_location_room: The room of one of the office hours meetings of the professor
        :type office_hours_location_room: str
        :param office_hours_location_map_uri: A hyperlink to the UTD room locator of one of the office hours meetings of the professor
        :type office_hours_location_map_uri: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._professor_search_serialize(
            offset=offset,
            first_name=first_name,
            last_name=last_name,
            titles=titles,
            email=email,
            phone_number=phone_number,
            office_building=office_building,
            office_room=office_room,
            office_map_uri=office_map_uri,
            profile_uri=profile_uri,
            image_uri=image_uri,
            office_hours_start_date=office_hours_start_date,
            office_hours_end_date=office_hours_end_date,
            office_hours_meeting_days=office_hours_meeting_days,
            office_hours_start_time=office_hours_start_time,
            office_hours_end_time=office_hours_end_time,
            office_hours_modality=office_hours_modality,
            office_hours_location_building=office_hours_location_building,
            office_hours_location_room=office_hours_location_room,
            office_hours_location_map_uri=office_hours_location_map_uri,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaProfessor",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _professor_search_serialize(
        self,
        offset,
        first_name,
        last_name,
        titles,
        email,
        phone_number,
        office_building,
        office_room,
        office_map_uri,
        profile_uri,
        image_uri,
        office_hours_start_date,
        office_hours_end_date,
        office_hours_meeting_days,
        office_hours_start_time,
        office_hours_end_time,
        office_hours_modality,
        office_hours_location_building,
        office_hours_location_room,
        office_hours_location_map_uri,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if first_name is not None:
            
            _query_params.append(('first_name', first_name))
            
        if last_name is not None:
            
            _query_params.append(('last_name', last_name))
            
        if titles is not None:
            
            _query_params.append(('titles', titles))
            
        if email is not None:
            
            _query_params.append(('email', email))
            
        if phone_number is not None:
            
            _query_params.append(('phone_number', phone_number))
            
        if office_building is not None:
            
            _query_params.append(('office.building', office_building))
            
        if office_room is not None:
            
            _query_params.append(('office.room', office_room))
            
        if office_map_uri is not None:
            
            _query_params.append(('office.map_uri', office_map_uri))
            
        if profile_uri is not None:
            
            _query_params.append(('profile_uri', profile_uri))
            
        if image_uri is not None:
            
            _query_params.append(('image_uri', image_uri))
            
        if office_hours_start_date is not None:
            
            _query_params.append(('office_hours.start_date', office_hours_start_date))
            
        if office_hours_end_date is not None:
            
            _query_params.append(('office_hours.end_date', office_hours_end_date))
            
        if office_hours_meeting_days is not None:
            
            _query_params.append(('office_hours.meeting_days', office_hours_meeting_days))
            
        if office_hours_start_time is not None:
            
            _query_params.append(('office_hours.start_time', office_hours_start_time))
            
        if office_hours_end_time is not None:
            
            _query_params.append(('office_hours.end_time', office_hours_end_time))
            
        if office_hours_modality is not None:
            
            _query_params.append(('office_hours.modality', office_hours_modality))
            
        if office_hours_location_building is not None:
            
            _query_params.append(('office_hours.location.building', office_hours_location_building))
            
        if office_hours_location_room is not None:
            
            _query_params.append(('office_hours.location.room', office_hours_location_room))
            
        if office_hours_location_map_uri is not None:
            
            _query_params.append(('office_hours.location.map_uri', office_hours_location_map_uri))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/professor',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def professor_section_by_id(
        self,
        id: Annotated[StrictStr, Field(description="ID of the professor to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseArraySchemaSection:
        """professor_section_by_id

        \"Returns all the sections taught by the professor with given ID\"

        :param id: ID of the professor to get (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._professor_section_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaSection",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def professor_section_by_id_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="ID of the professor to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseArraySchemaSection]:
        """professor_section_by_id

        \"Returns all the sections taught by the professor with given ID\"

        :param id: ID of the professor to get (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._professor_section_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaSection",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def professor_section_by_id_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="ID of the professor to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """professor_section_by_id

        \"Returns all the sections taught by the professor with given ID\"

        :param id: ID of the professor to get (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._professor_section_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaSection",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _professor_section_by_id_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/professor/{id}/sections',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def professor_section_search(
        self,
        former_offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of professors (e.g. For starting at the 17th professor, former_offset=16).")] = None,
        latter_offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of sections (e.g. For starting at the 4th section, latter_offset=3).")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="The professor's first name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="The professor's last name")] = None,
        titles: Annotated[Optional[StrictStr], Field(description="One of the professor's title")] = None,
        email: Annotated[Optional[StrictStr], Field(description="The professor's email address")] = None,
        phone_number: Annotated[Optional[StrictStr], Field(description="The professor's phone number")] = None,
        office_building: Annotated[Optional[StrictStr], Field(description="The building of the location of the professor's office")] = None,
        office_room: Annotated[Optional[StrictStr], Field(description="The room of the location of the professor's office")] = None,
        office_map_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink to the UTD room locator of the professor's office")] = None,
        profile_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink pointing to the professor's official university profile")] = None,
        image_uri: Annotated[Optional[StrictStr], Field(description="A link to the image used for the professor on the professor's official university profile")] = None,
        office_hours_start_date: Annotated[Optional[StrictStr], Field(description="The start date of one of the office hours meetings of the professor")] = None,
        office_hours_end_date: Annotated[Optional[StrictStr], Field(description="The end date of one of the office hours meetings of the professor")] = None,
        office_hours_meeting_days: Annotated[Optional[StrictStr], Field(description="One of the days that one of the office hours meetings of the professor")] = None,
        office_hours_start_time: Annotated[Optional[StrictStr], Field(description="The time one of the office hours meetings of the professor starts")] = None,
        office_hours_end_time: Annotated[Optional[StrictStr], Field(description="The time one of the office hours meetings of the professor ends")] = None,
        office_hours_modality: Annotated[Optional[StrictStr], Field(description="The modality of one of the office hours meetings of the professor")] = None,
        office_hours_location_building: Annotated[Optional[StrictStr], Field(description="The building of one of the office hours meetings of the professor")] = None,
        office_hours_location_room: Annotated[Optional[StrictStr], Field(description="The room of one of the office hours meetings of the professor")] = None,
        office_hours_location_map_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink to the UTD room locator of one of the office hours meetings of the professor")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseArraySchemaSection:
        """professor_section_search

        \"Returns paginated list of the sections of all the professors matching the query's string-typed key-value pairs. See former_offset and latter_offset for pagination details.\"

        :param former_offset: The starting position of the current page of professors (e.g. For starting at the 17th professor, former_offset=16).
        :type former_offset: float
        :param latter_offset: The starting position of the current page of sections (e.g. For starting at the 4th section, latter_offset=3).
        :type latter_offset: float
        :param first_name: The professor's first name
        :type first_name: str
        :param last_name: The professor's last name
        :type last_name: str
        :param titles: One of the professor's title
        :type titles: str
        :param email: The professor's email address
        :type email: str
        :param phone_number: The professor's phone number
        :type phone_number: str
        :param office_building: The building of the location of the professor's office
        :type office_building: str
        :param office_room: The room of the location of the professor's office
        :type office_room: str
        :param office_map_uri: A hyperlink to the UTD room locator of the professor's office
        :type office_map_uri: str
        :param profile_uri: A hyperlink pointing to the professor's official university profile
        :type profile_uri: str
        :param image_uri: A link to the image used for the professor on the professor's official university profile
        :type image_uri: str
        :param office_hours_start_date: The start date of one of the office hours meetings of the professor
        :type office_hours_start_date: str
        :param office_hours_end_date: The end date of one of the office hours meetings of the professor
        :type office_hours_end_date: str
        :param office_hours_meeting_days: One of the days that one of the office hours meetings of the professor
        :type office_hours_meeting_days: str
        :param office_hours_start_time: The time one of the office hours meetings of the professor starts
        :type office_hours_start_time: str
        :param office_hours_end_time: The time one of the office hours meetings of the professor ends
        :type office_hours_end_time: str
        :param office_hours_modality: The modality of one of the office hours meetings of the professor
        :type office_hours_modality: str
        :param office_hours_location_building: The building of one of the office hours meetings of the professor
        :type office_hours_location_building: str
        :param office_hours_location_room: The room of one of the office hours meetings of the professor
        :type office_hours_location_room: str
        :param office_hours_location_map_uri: A hyperlink to the UTD room locator of one of the office hours meetings of the professor
        :type office_hours_location_map_uri: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._professor_section_search_serialize(
            former_offset=former_offset,
            latter_offset=latter_offset,
            first_name=first_name,
            last_name=last_name,
            titles=titles,
            email=email,
            phone_number=phone_number,
            office_building=office_building,
            office_room=office_room,
            office_map_uri=office_map_uri,
            profile_uri=profile_uri,
            image_uri=image_uri,
            office_hours_start_date=office_hours_start_date,
            office_hours_end_date=office_hours_end_date,
            office_hours_meeting_days=office_hours_meeting_days,
            office_hours_start_time=office_hours_start_time,
            office_hours_end_time=office_hours_end_time,
            office_hours_modality=office_hours_modality,
            office_hours_location_building=office_hours_location_building,
            office_hours_location_room=office_hours_location_room,
            office_hours_location_map_uri=office_hours_location_map_uri,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaSection",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def professor_section_search_with_http_info(
        self,
        former_offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of professors (e.g. For starting at the 17th professor, former_offset=16).")] = None,
        latter_offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of sections (e.g. For starting at the 4th section, latter_offset=3).")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="The professor's first name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="The professor's last name")] = None,
        titles: Annotated[Optional[StrictStr], Field(description="One of the professor's title")] = None,
        email: Annotated[Optional[StrictStr], Field(description="The professor's email address")] = None,
        phone_number: Annotated[Optional[StrictStr], Field(description="The professor's phone number")] = None,
        office_building: Annotated[Optional[StrictStr], Field(description="The building of the location of the professor's office")] = None,
        office_room: Annotated[Optional[StrictStr], Field(description="The room of the location of the professor's office")] = None,
        office_map_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink to the UTD room locator of the professor's office")] = None,
        profile_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink pointing to the professor's official university profile")] = None,
        image_uri: Annotated[Optional[StrictStr], Field(description="A link to the image used for the professor on the professor's official university profile")] = None,
        office_hours_start_date: Annotated[Optional[StrictStr], Field(description="The start date of one of the office hours meetings of the professor")] = None,
        office_hours_end_date: Annotated[Optional[StrictStr], Field(description="The end date of one of the office hours meetings of the professor")] = None,
        office_hours_meeting_days: Annotated[Optional[StrictStr], Field(description="One of the days that one of the office hours meetings of the professor")] = None,
        office_hours_start_time: Annotated[Optional[StrictStr], Field(description="The time one of the office hours meetings of the professor starts")] = None,
        office_hours_end_time: Annotated[Optional[StrictStr], Field(description="The time one of the office hours meetings of the professor ends")] = None,
        office_hours_modality: Annotated[Optional[StrictStr], Field(description="The modality of one of the office hours meetings of the professor")] = None,
        office_hours_location_building: Annotated[Optional[StrictStr], Field(description="The building of one of the office hours meetings of the professor")] = None,
        office_hours_location_room: Annotated[Optional[StrictStr], Field(description="The room of one of the office hours meetings of the professor")] = None,
        office_hours_location_map_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink to the UTD room locator of one of the office hours meetings of the professor")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseArraySchemaSection]:
        """professor_section_search

        \"Returns paginated list of the sections of all the professors matching the query's string-typed key-value pairs. See former_offset and latter_offset for pagination details.\"

        :param former_offset: The starting position of the current page of professors (e.g. For starting at the 17th professor, former_offset=16).
        :type former_offset: float
        :param latter_offset: The starting position of the current page of sections (e.g. For starting at the 4th section, latter_offset=3).
        :type latter_offset: float
        :param first_name: The professor's first name
        :type first_name: str
        :param last_name: The professor's last name
        :type last_name: str
        :param titles: One of the professor's title
        :type titles: str
        :param email: The professor's email address
        :type email: str
        :param phone_number: The professor's phone number
        :type phone_number: str
        :param office_building: The building of the location of the professor's office
        :type office_building: str
        :param office_room: The room of the location of the professor's office
        :type office_room: str
        :param office_map_uri: A hyperlink to the UTD room locator of the professor's office
        :type office_map_uri: str
        :param profile_uri: A hyperlink pointing to the professor's official university profile
        :type profile_uri: str
        :param image_uri: A link to the image used for the professor on the professor's official university profile
        :type image_uri: str
        :param office_hours_start_date: The start date of one of the office hours meetings of the professor
        :type office_hours_start_date: str
        :param office_hours_end_date: The end date of one of the office hours meetings of the professor
        :type office_hours_end_date: str
        :param office_hours_meeting_days: One of the days that one of the office hours meetings of the professor
        :type office_hours_meeting_days: str
        :param office_hours_start_time: The time one of the office hours meetings of the professor starts
        :type office_hours_start_time: str
        :param office_hours_end_time: The time one of the office hours meetings of the professor ends
        :type office_hours_end_time: str
        :param office_hours_modality: The modality of one of the office hours meetings of the professor
        :type office_hours_modality: str
        :param office_hours_location_building: The building of one of the office hours meetings of the professor
        :type office_hours_location_building: str
        :param office_hours_location_room: The room of one of the office hours meetings of the professor
        :type office_hours_location_room: str
        :param office_hours_location_map_uri: A hyperlink to the UTD room locator of one of the office hours meetings of the professor
        :type office_hours_location_map_uri: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._professor_section_search_serialize(
            former_offset=former_offset,
            latter_offset=latter_offset,
            first_name=first_name,
            last_name=last_name,
            titles=titles,
            email=email,
            phone_number=phone_number,
            office_building=office_building,
            office_room=office_room,
            office_map_uri=office_map_uri,
            profile_uri=profile_uri,
            image_uri=image_uri,
            office_hours_start_date=office_hours_start_date,
            office_hours_end_date=office_hours_end_date,
            office_hours_meeting_days=office_hours_meeting_days,
            office_hours_start_time=office_hours_start_time,
            office_hours_end_time=office_hours_end_time,
            office_hours_modality=office_hours_modality,
            office_hours_location_building=office_hours_location_building,
            office_hours_location_room=office_hours_location_room,
            office_hours_location_map_uri=office_hours_location_map_uri,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaSection",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def professor_section_search_without_preload_content(
        self,
        former_offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of professors (e.g. For starting at the 17th professor, former_offset=16).")] = None,
        latter_offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of sections (e.g. For starting at the 4th section, latter_offset=3).")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="The professor's first name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="The professor's last name")] = None,
        titles: Annotated[Optional[StrictStr], Field(description="One of the professor's title")] = None,
        email: Annotated[Optional[StrictStr], Field(description="The professor's email address")] = None,
        phone_number: Annotated[Optional[StrictStr], Field(description="The professor's phone number")] = None,
        office_building: Annotated[Optional[StrictStr], Field(description="The building of the location of the professor's office")] = None,
        office_room: Annotated[Optional[StrictStr], Field(description="The room of the location of the professor's office")] = None,
        office_map_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink to the UTD room locator of the professor's office")] = None,
        profile_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink pointing to the professor's official university profile")] = None,
        image_uri: Annotated[Optional[StrictStr], Field(description="A link to the image used for the professor on the professor's official university profile")] = None,
        office_hours_start_date: Annotated[Optional[StrictStr], Field(description="The start date of one of the office hours meetings of the professor")] = None,
        office_hours_end_date: Annotated[Optional[StrictStr], Field(description="The end date of one of the office hours meetings of the professor")] = None,
        office_hours_meeting_days: Annotated[Optional[StrictStr], Field(description="One of the days that one of the office hours meetings of the professor")] = None,
        office_hours_start_time: Annotated[Optional[StrictStr], Field(description="The time one of the office hours meetings of the professor starts")] = None,
        office_hours_end_time: Annotated[Optional[StrictStr], Field(description="The time one of the office hours meetings of the professor ends")] = None,
        office_hours_modality: Annotated[Optional[StrictStr], Field(description="The modality of one of the office hours meetings of the professor")] = None,
        office_hours_location_building: Annotated[Optional[StrictStr], Field(description="The building of one of the office hours meetings of the professor")] = None,
        office_hours_location_room: Annotated[Optional[StrictStr], Field(description="The room of one of the office hours meetings of the professor")] = None,
        office_hours_location_map_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink to the UTD room locator of one of the office hours meetings of the professor")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """professor_section_search

        \"Returns paginated list of the sections of all the professors matching the query's string-typed key-value pairs. See former_offset and latter_offset for pagination details.\"

        :param former_offset: The starting position of the current page of professors (e.g. For starting at the 17th professor, former_offset=16).
        :type former_offset: float
        :param latter_offset: The starting position of the current page of sections (e.g. For starting at the 4th section, latter_offset=3).
        :type latter_offset: float
        :param first_name: The professor's first name
        :type first_name: str
        :param last_name: The professor's last name
        :type last_name: str
        :param titles: One of the professor's title
        :type titles: str
        :param email: The professor's email address
        :type email: str
        :param phone_number: The professor's phone number
        :type phone_number: str
        :param office_building: The building of the location of the professor's office
        :type office_building: str
        :param office_room: The room of the location of the professor's office
        :type office_room: str
        :param office_map_uri: A hyperlink to the UTD room locator of the professor's office
        :type office_map_uri: str
        :param profile_uri: A hyperlink pointing to the professor's official university profile
        :type profile_uri: str
        :param image_uri: A link to the image used for the professor on the professor's official university profile
        :type image_uri: str
        :param office_hours_start_date: The start date of one of the office hours meetings of the professor
        :type office_hours_start_date: str
        :param office_hours_end_date: The end date of one of the office hours meetings of the professor
        :type office_hours_end_date: str
        :param office_hours_meeting_days: One of the days that one of the office hours meetings of the professor
        :type office_hours_meeting_days: str
        :param office_hours_start_time: The time one of the office hours meetings of the professor starts
        :type office_hours_start_time: str
        :param office_hours_end_time: The time one of the office hours meetings of the professor ends
        :type office_hours_end_time: str
        :param office_hours_modality: The modality of one of the office hours meetings of the professor
        :type office_hours_modality: str
        :param office_hours_location_building: The building of one of the office hours meetings of the professor
        :type office_hours_location_building: str
        :param office_hours_location_room: The room of one of the office hours meetings of the professor
        :type office_hours_location_room: str
        :param office_hours_location_map_uri: A hyperlink to the UTD room locator of one of the office hours meetings of the professor
        :type office_hours_location_map_uri: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._professor_section_search_serialize(
            former_offset=former_offset,
            latter_offset=latter_offset,
            first_name=first_name,
            last_name=last_name,
            titles=titles,
            email=email,
            phone_number=phone_number,
            office_building=office_building,
            office_room=office_room,
            office_map_uri=office_map_uri,
            profile_uri=profile_uri,
            image_uri=image_uri,
            office_hours_start_date=office_hours_start_date,
            office_hours_end_date=office_hours_end_date,
            office_hours_meeting_days=office_hours_meeting_days,
            office_hours_start_time=office_hours_start_time,
            office_hours_end_time=office_hours_end_time,
            office_hours_modality=office_hours_modality,
            office_hours_location_building=office_hours_location_building,
            office_hours_location_room=office_hours_location_room,
            office_hours_location_map_uri=office_hours_location_map_uri,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaSection",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _professor_section_search_serialize(
        self,
        former_offset,
        latter_offset,
        first_name,
        last_name,
        titles,
        email,
        phone_number,
        office_building,
        office_room,
        office_map_uri,
        profile_uri,
        image_uri,
        office_hours_start_date,
        office_hours_end_date,
        office_hours_meeting_days,
        office_hours_start_time,
        office_hours_end_time,
        office_hours_modality,
        office_hours_location_building,
        office_hours_location_room,
        office_hours_location_map_uri,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if former_offset is not None:
            
            _query_params.append(('former_offset', former_offset))
            
        if latter_offset is not None:
            
            _query_params.append(('latter_offset', latter_offset))
            
        if first_name is not None:
            
            _query_params.append(('first_name', first_name))
            
        if last_name is not None:
            
            _query_params.append(('last_name', last_name))
            
        if titles is not None:
            
            _query_params.append(('titles', titles))
            
        if email is not None:
            
            _query_params.append(('email', email))
            
        if phone_number is not None:
            
            _query_params.append(('phone_number', phone_number))
            
        if office_building is not None:
            
            _query_params.append(('office.building', office_building))
            
        if office_room is not None:
            
            _query_params.append(('office.room', office_room))
            
        if office_map_uri is not None:
            
            _query_params.append(('office.map_uri', office_map_uri))
            
        if profile_uri is not None:
            
            _query_params.append(('profile_uri', profile_uri))
            
        if image_uri is not None:
            
            _query_params.append(('image_uri', image_uri))
            
        if office_hours_start_date is not None:
            
            _query_params.append(('office_hours.start_date', office_hours_start_date))
            
        if office_hours_end_date is not None:
            
            _query_params.append(('office_hours.end_date', office_hours_end_date))
            
        if office_hours_meeting_days is not None:
            
            _query_params.append(('office_hours.meeting_days', office_hours_meeting_days))
            
        if office_hours_start_time is not None:
            
            _query_params.append(('office_hours.start_time', office_hours_start_time))
            
        if office_hours_end_time is not None:
            
            _query_params.append(('office_hours.end_time', office_hours_end_time))
            
        if office_hours_modality is not None:
            
            _query_params.append(('office_hours.modality', office_hours_modality))
            
        if office_hours_location_building is not None:
            
            _query_params.append(('office_hours.location.building', office_hours_location_building))
            
        if office_hours_location_room is not None:
            
            _query_params.append(('office_hours.location.room', office_hours_location_room))
            
        if office_hours_location_map_uri is not None:
            
            _query_params.append(('office_hours.location.map_uri', office_hours_location_map_uri))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/professor/sections',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def rooms(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseArraySchemaBuildingRooms:
        """rooms

        \"Returns all schedulable rooms being used in the current and futures semesters from CourseBook, Astra, and Mazevo\"

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._rooms_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaBuildingRooms",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def rooms_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseArraySchemaBuildingRooms]:
        """rooms

        \"Returns all schedulable rooms being used in the current and futures semesters from CourseBook, Astra, and Mazevo\"

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._rooms_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaBuildingRooms",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def rooms_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """rooms

        \"Returns all schedulable rooms being used in the current and futures semesters from CourseBook, Astra, and Mazevo\"

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._rooms_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaBuildingRooms",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _rooms_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/rooms',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def section_by_id(
        self,
        id: Annotated[StrictStr, Field(description="ID of the section to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseSchemaSection:
        """section_by_id

        \"Returns the section with given ID\"

        :param id: ID of the section to get (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._section_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaSection",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def section_by_id_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="ID of the section to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseSchemaSection]:
        """section_by_id

        \"Returns the section with given ID\"

        :param id: ID of the section to get (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._section_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaSection",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def section_by_id_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="ID of the section to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """section_by_id

        \"Returns the section with given ID\"

        :param id: ID of the section to get (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._section_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseSchemaSection",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _section_by_id_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/section/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def section_search(
        self,
        offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of sections (e.g. For starting at the 17th professor, offset=16).")] = None,
        section_number: Annotated[Optional[StrictStr], Field(description="The section's official number")] = None,
        academic_session_name: Annotated[Optional[StrictStr], Field(description="The name of the academic session of the section")] = None,
        academic_session_start_date: Annotated[Optional[StrictStr], Field(description="The date of classes starting for the section")] = None,
        academic_session_end_date: Annotated[Optional[StrictStr], Field(description="The date of classes ending for the section")] = None,
        teaching_assistants_first_name: Annotated[Optional[StrictStr], Field(description="The first name of one of the teaching assistants of the section")] = None,
        teaching_assistants_last_name: Annotated[Optional[StrictStr], Field(description="The last name of one of the teaching assistants of the section")] = None,
        teaching_assistants_role: Annotated[Optional[StrictStr], Field(description="The role of one of the teaching assistants of the section")] = None,
        teaching_assistants_email: Annotated[Optional[StrictStr], Field(description="The email of one of the teaching assistants of the section")] = None,
        internal_class_number: Annotated[Optional[StrictStr], Field(description="The internal (university) number used to reference this section")] = None,
        instruction_mode: Annotated[Optional[StrictStr], Field(description="The instruction modality for this section")] = None,
        meetings_start_date: Annotated[Optional[StrictStr], Field(description="The start date of one of the section's meetings")] = None,
        meetings_end_date: Annotated[Optional[StrictStr], Field(description="The end date of one of the section's meetings")] = None,
        meetings_meeting_days: Annotated[Optional[StrictStr], Field(description="One of the days that one of the section's meetings")] = None,
        meetings_start_time: Annotated[Optional[StrictStr], Field(description="The time one of the section's meetings starts")] = None,
        meetings_end_time: Annotated[Optional[StrictStr], Field(description="The time one of the section's meetings ends")] = None,
        meetings_modality: Annotated[Optional[StrictStr], Field(description="The modality of one of the section's meetings")] = None,
        meetings_location_building: Annotated[Optional[StrictStr], Field(description="The building of one of the section's meetings")] = None,
        meetings_location_room: Annotated[Optional[StrictStr], Field(description="The room of one of the section's meetings")] = None,
        meetings_location_map_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink to the UTD room locator of one of the section's meetings")] = None,
        core_flags: Annotated[Optional[StrictStr], Field(description="One of core requirement codes this section fulfills")] = None,
        syllabus_uri: Annotated[Optional[StrictStr], Field(description="A link to the syllabus on the web")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseArraySchemaSection:
        """section_search

        \"Returns paginated list of sections matching the query's string-typed key-value pairs. See offset for more details on pagination.\"

        :param offset: The starting position of the current page of sections (e.g. For starting at the 17th professor, offset=16).
        :type offset: float
        :param section_number: The section's official number
        :type section_number: str
        :param academic_session_name: The name of the academic session of the section
        :type academic_session_name: str
        :param academic_session_start_date: The date of classes starting for the section
        :type academic_session_start_date: str
        :param academic_session_end_date: The date of classes ending for the section
        :type academic_session_end_date: str
        :param teaching_assistants_first_name: The first name of one of the teaching assistants of the section
        :type teaching_assistants_first_name: str
        :param teaching_assistants_last_name: The last name of one of the teaching assistants of the section
        :type teaching_assistants_last_name: str
        :param teaching_assistants_role: The role of one of the teaching assistants of the section
        :type teaching_assistants_role: str
        :param teaching_assistants_email: The email of one of the teaching assistants of the section
        :type teaching_assistants_email: str
        :param internal_class_number: The internal (university) number used to reference this section
        :type internal_class_number: str
        :param instruction_mode: The instruction modality for this section
        :type instruction_mode: str
        :param meetings_start_date: The start date of one of the section's meetings
        :type meetings_start_date: str
        :param meetings_end_date: The end date of one of the section's meetings
        :type meetings_end_date: str
        :param meetings_meeting_days: One of the days that one of the section's meetings
        :type meetings_meeting_days: str
        :param meetings_start_time: The time one of the section's meetings starts
        :type meetings_start_time: str
        :param meetings_end_time: The time one of the section's meetings ends
        :type meetings_end_time: str
        :param meetings_modality: The modality of one of the section's meetings
        :type meetings_modality: str
        :param meetings_location_building: The building of one of the section's meetings
        :type meetings_location_building: str
        :param meetings_location_room: The room of one of the section's meetings
        :type meetings_location_room: str
        :param meetings_location_map_uri: A hyperlink to the UTD room locator of one of the section's meetings
        :type meetings_location_map_uri: str
        :param core_flags: One of core requirement codes this section fulfills
        :type core_flags: str
        :param syllabus_uri: A link to the syllabus on the web
        :type syllabus_uri: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._section_search_serialize(
            offset=offset,
            section_number=section_number,
            academic_session_name=academic_session_name,
            academic_session_start_date=academic_session_start_date,
            academic_session_end_date=academic_session_end_date,
            teaching_assistants_first_name=teaching_assistants_first_name,
            teaching_assistants_last_name=teaching_assistants_last_name,
            teaching_assistants_role=teaching_assistants_role,
            teaching_assistants_email=teaching_assistants_email,
            internal_class_number=internal_class_number,
            instruction_mode=instruction_mode,
            meetings_start_date=meetings_start_date,
            meetings_end_date=meetings_end_date,
            meetings_meeting_days=meetings_meeting_days,
            meetings_start_time=meetings_start_time,
            meetings_end_time=meetings_end_time,
            meetings_modality=meetings_modality,
            meetings_location_building=meetings_location_building,
            meetings_location_room=meetings_location_room,
            meetings_location_map_uri=meetings_location_map_uri,
            core_flags=core_flags,
            syllabus_uri=syllabus_uri,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaSection",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def section_search_with_http_info(
        self,
        offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of sections (e.g. For starting at the 17th professor, offset=16).")] = None,
        section_number: Annotated[Optional[StrictStr], Field(description="The section's official number")] = None,
        academic_session_name: Annotated[Optional[StrictStr], Field(description="The name of the academic session of the section")] = None,
        academic_session_start_date: Annotated[Optional[StrictStr], Field(description="The date of classes starting for the section")] = None,
        academic_session_end_date: Annotated[Optional[StrictStr], Field(description="The date of classes ending for the section")] = None,
        teaching_assistants_first_name: Annotated[Optional[StrictStr], Field(description="The first name of one of the teaching assistants of the section")] = None,
        teaching_assistants_last_name: Annotated[Optional[StrictStr], Field(description="The last name of one of the teaching assistants of the section")] = None,
        teaching_assistants_role: Annotated[Optional[StrictStr], Field(description="The role of one of the teaching assistants of the section")] = None,
        teaching_assistants_email: Annotated[Optional[StrictStr], Field(description="The email of one of the teaching assistants of the section")] = None,
        internal_class_number: Annotated[Optional[StrictStr], Field(description="The internal (university) number used to reference this section")] = None,
        instruction_mode: Annotated[Optional[StrictStr], Field(description="The instruction modality for this section")] = None,
        meetings_start_date: Annotated[Optional[StrictStr], Field(description="The start date of one of the section's meetings")] = None,
        meetings_end_date: Annotated[Optional[StrictStr], Field(description="The end date of one of the section's meetings")] = None,
        meetings_meeting_days: Annotated[Optional[StrictStr], Field(description="One of the days that one of the section's meetings")] = None,
        meetings_start_time: Annotated[Optional[StrictStr], Field(description="The time one of the section's meetings starts")] = None,
        meetings_end_time: Annotated[Optional[StrictStr], Field(description="The time one of the section's meetings ends")] = None,
        meetings_modality: Annotated[Optional[StrictStr], Field(description="The modality of one of the section's meetings")] = None,
        meetings_location_building: Annotated[Optional[StrictStr], Field(description="The building of one of the section's meetings")] = None,
        meetings_location_room: Annotated[Optional[StrictStr], Field(description="The room of one of the section's meetings")] = None,
        meetings_location_map_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink to the UTD room locator of one of the section's meetings")] = None,
        core_flags: Annotated[Optional[StrictStr], Field(description="One of core requirement codes this section fulfills")] = None,
        syllabus_uri: Annotated[Optional[StrictStr], Field(description="A link to the syllabus on the web")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseArraySchemaSection]:
        """section_search

        \"Returns paginated list of sections matching the query's string-typed key-value pairs. See offset for more details on pagination.\"

        :param offset: The starting position of the current page of sections (e.g. For starting at the 17th professor, offset=16).
        :type offset: float
        :param section_number: The section's official number
        :type section_number: str
        :param academic_session_name: The name of the academic session of the section
        :type academic_session_name: str
        :param academic_session_start_date: The date of classes starting for the section
        :type academic_session_start_date: str
        :param academic_session_end_date: The date of classes ending for the section
        :type academic_session_end_date: str
        :param teaching_assistants_first_name: The first name of one of the teaching assistants of the section
        :type teaching_assistants_first_name: str
        :param teaching_assistants_last_name: The last name of one of the teaching assistants of the section
        :type teaching_assistants_last_name: str
        :param teaching_assistants_role: The role of one of the teaching assistants of the section
        :type teaching_assistants_role: str
        :param teaching_assistants_email: The email of one of the teaching assistants of the section
        :type teaching_assistants_email: str
        :param internal_class_number: The internal (university) number used to reference this section
        :type internal_class_number: str
        :param instruction_mode: The instruction modality for this section
        :type instruction_mode: str
        :param meetings_start_date: The start date of one of the section's meetings
        :type meetings_start_date: str
        :param meetings_end_date: The end date of one of the section's meetings
        :type meetings_end_date: str
        :param meetings_meeting_days: One of the days that one of the section's meetings
        :type meetings_meeting_days: str
        :param meetings_start_time: The time one of the section's meetings starts
        :type meetings_start_time: str
        :param meetings_end_time: The time one of the section's meetings ends
        :type meetings_end_time: str
        :param meetings_modality: The modality of one of the section's meetings
        :type meetings_modality: str
        :param meetings_location_building: The building of one of the section's meetings
        :type meetings_location_building: str
        :param meetings_location_room: The room of one of the section's meetings
        :type meetings_location_room: str
        :param meetings_location_map_uri: A hyperlink to the UTD room locator of one of the section's meetings
        :type meetings_location_map_uri: str
        :param core_flags: One of core requirement codes this section fulfills
        :type core_flags: str
        :param syllabus_uri: A link to the syllabus on the web
        :type syllabus_uri: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._section_search_serialize(
            offset=offset,
            section_number=section_number,
            academic_session_name=academic_session_name,
            academic_session_start_date=academic_session_start_date,
            academic_session_end_date=academic_session_end_date,
            teaching_assistants_first_name=teaching_assistants_first_name,
            teaching_assistants_last_name=teaching_assistants_last_name,
            teaching_assistants_role=teaching_assistants_role,
            teaching_assistants_email=teaching_assistants_email,
            internal_class_number=internal_class_number,
            instruction_mode=instruction_mode,
            meetings_start_date=meetings_start_date,
            meetings_end_date=meetings_end_date,
            meetings_meeting_days=meetings_meeting_days,
            meetings_start_time=meetings_start_time,
            meetings_end_time=meetings_end_time,
            meetings_modality=meetings_modality,
            meetings_location_building=meetings_location_building,
            meetings_location_room=meetings_location_room,
            meetings_location_map_uri=meetings_location_map_uri,
            core_flags=core_flags,
            syllabus_uri=syllabus_uri,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaSection",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def section_search_without_preload_content(
        self,
        offset: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The starting position of the current page of sections (e.g. For starting at the 17th professor, offset=16).")] = None,
        section_number: Annotated[Optional[StrictStr], Field(description="The section's official number")] = None,
        academic_session_name: Annotated[Optional[StrictStr], Field(description="The name of the academic session of the section")] = None,
        academic_session_start_date: Annotated[Optional[StrictStr], Field(description="The date of classes starting for the section")] = None,
        academic_session_end_date: Annotated[Optional[StrictStr], Field(description="The date of classes ending for the section")] = None,
        teaching_assistants_first_name: Annotated[Optional[StrictStr], Field(description="The first name of one of the teaching assistants of the section")] = None,
        teaching_assistants_last_name: Annotated[Optional[StrictStr], Field(description="The last name of one of the teaching assistants of the section")] = None,
        teaching_assistants_role: Annotated[Optional[StrictStr], Field(description="The role of one of the teaching assistants of the section")] = None,
        teaching_assistants_email: Annotated[Optional[StrictStr], Field(description="The email of one of the teaching assistants of the section")] = None,
        internal_class_number: Annotated[Optional[StrictStr], Field(description="The internal (university) number used to reference this section")] = None,
        instruction_mode: Annotated[Optional[StrictStr], Field(description="The instruction modality for this section")] = None,
        meetings_start_date: Annotated[Optional[StrictStr], Field(description="The start date of one of the section's meetings")] = None,
        meetings_end_date: Annotated[Optional[StrictStr], Field(description="The end date of one of the section's meetings")] = None,
        meetings_meeting_days: Annotated[Optional[StrictStr], Field(description="One of the days that one of the section's meetings")] = None,
        meetings_start_time: Annotated[Optional[StrictStr], Field(description="The time one of the section's meetings starts")] = None,
        meetings_end_time: Annotated[Optional[StrictStr], Field(description="The time one of the section's meetings ends")] = None,
        meetings_modality: Annotated[Optional[StrictStr], Field(description="The modality of one of the section's meetings")] = None,
        meetings_location_building: Annotated[Optional[StrictStr], Field(description="The building of one of the section's meetings")] = None,
        meetings_location_room: Annotated[Optional[StrictStr], Field(description="The room of one of the section's meetings")] = None,
        meetings_location_map_uri: Annotated[Optional[StrictStr], Field(description="A hyperlink to the UTD room locator of one of the section's meetings")] = None,
        core_flags: Annotated[Optional[StrictStr], Field(description="One of core requirement codes this section fulfills")] = None,
        syllabus_uri: Annotated[Optional[StrictStr], Field(description="A link to the syllabus on the web")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """section_search

        \"Returns paginated list of sections matching the query's string-typed key-value pairs. See offset for more details on pagination.\"

        :param offset: The starting position of the current page of sections (e.g. For starting at the 17th professor, offset=16).
        :type offset: float
        :param section_number: The section's official number
        :type section_number: str
        :param academic_session_name: The name of the academic session of the section
        :type academic_session_name: str
        :param academic_session_start_date: The date of classes starting for the section
        :type academic_session_start_date: str
        :param academic_session_end_date: The date of classes ending for the section
        :type academic_session_end_date: str
        :param teaching_assistants_first_name: The first name of one of the teaching assistants of the section
        :type teaching_assistants_first_name: str
        :param teaching_assistants_last_name: The last name of one of the teaching assistants of the section
        :type teaching_assistants_last_name: str
        :param teaching_assistants_role: The role of one of the teaching assistants of the section
        :type teaching_assistants_role: str
        :param teaching_assistants_email: The email of one of the teaching assistants of the section
        :type teaching_assistants_email: str
        :param internal_class_number: The internal (university) number used to reference this section
        :type internal_class_number: str
        :param instruction_mode: The instruction modality for this section
        :type instruction_mode: str
        :param meetings_start_date: The start date of one of the section's meetings
        :type meetings_start_date: str
        :param meetings_end_date: The end date of one of the section's meetings
        :type meetings_end_date: str
        :param meetings_meeting_days: One of the days that one of the section's meetings
        :type meetings_meeting_days: str
        :param meetings_start_time: The time one of the section's meetings starts
        :type meetings_start_time: str
        :param meetings_end_time: The time one of the section's meetings ends
        :type meetings_end_time: str
        :param meetings_modality: The modality of one of the section's meetings
        :type meetings_modality: str
        :param meetings_location_building: The building of one of the section's meetings
        :type meetings_location_building: str
        :param meetings_location_room: The room of one of the section's meetings
        :type meetings_location_room: str
        :param meetings_location_map_uri: A hyperlink to the UTD room locator of one of the section's meetings
        :type meetings_location_map_uri: str
        :param core_flags: One of core requirement codes this section fulfills
        :type core_flags: str
        :param syllabus_uri: A link to the syllabus on the web
        :type syllabus_uri: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._section_search_serialize(
            offset=offset,
            section_number=section_number,
            academic_session_name=academic_session_name,
            academic_session_start_date=academic_session_start_date,
            academic_session_end_date=academic_session_end_date,
            teaching_assistants_first_name=teaching_assistants_first_name,
            teaching_assistants_last_name=teaching_assistants_last_name,
            teaching_assistants_role=teaching_assistants_role,
            teaching_assistants_email=teaching_assistants_email,
            internal_class_number=internal_class_number,
            instruction_mode=instruction_mode,
            meetings_start_date=meetings_start_date,
            meetings_end_date=meetings_end_date,
            meetings_meeting_days=meetings_meeting_days,
            meetings_start_time=meetings_start_time,
            meetings_end_time=meetings_end_time,
            meetings_modality=meetings_modality,
            meetings_location_building=meetings_location_building,
            meetings_location_room=meetings_location_room,
            meetings_location_map_uri=meetings_location_map_uri,
            core_flags=core_flags,
            syllabus_uri=syllabus_uri,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaSection",
            '400': "SchemaAPIResponseString",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _section_search_serialize(
        self,
        offset,
        section_number,
        academic_session_name,
        academic_session_start_date,
        academic_session_end_date,
        teaching_assistants_first_name,
        teaching_assistants_last_name,
        teaching_assistants_role,
        teaching_assistants_email,
        internal_class_number,
        instruction_mode,
        meetings_start_date,
        meetings_end_date,
        meetings_meeting_days,
        meetings_start_time,
        meetings_end_time,
        meetings_modality,
        meetings_location_building,
        meetings_location_room,
        meetings_location_map_uri,
        core_flags,
        syllabus_uri,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if section_number is not None:
            
            _query_params.append(('section_number', section_number))
            
        if academic_session_name is not None:
            
            _query_params.append(('academic_session.name', academic_session_name))
            
        if academic_session_start_date is not None:
            
            _query_params.append(('academic_session.start_date', academic_session_start_date))
            
        if academic_session_end_date is not None:
            
            _query_params.append(('academic_session.end_date', academic_session_end_date))
            
        if teaching_assistants_first_name is not None:
            
            _query_params.append(('teaching_assistants.first_name', teaching_assistants_first_name))
            
        if teaching_assistants_last_name is not None:
            
            _query_params.append(('teaching_assistants.last_name', teaching_assistants_last_name))
            
        if teaching_assistants_role is not None:
            
            _query_params.append(('teaching_assistants.role', teaching_assistants_role))
            
        if teaching_assistants_email is not None:
            
            _query_params.append(('teaching_assistants.email', teaching_assistants_email))
            
        if internal_class_number is not None:
            
            _query_params.append(('internal_class_number', internal_class_number))
            
        if instruction_mode is not None:
            
            _query_params.append(('instruction_mode', instruction_mode))
            
        if meetings_start_date is not None:
            
            _query_params.append(('meetings.start_date', meetings_start_date))
            
        if meetings_end_date is not None:
            
            _query_params.append(('meetings.end_date', meetings_end_date))
            
        if meetings_meeting_days is not None:
            
            _query_params.append(('meetings.meeting_days', meetings_meeting_days))
            
        if meetings_start_time is not None:
            
            _query_params.append(('meetings.start_time', meetings_start_time))
            
        if meetings_end_time is not None:
            
            _query_params.append(('meetings.end_time', meetings_end_time))
            
        if meetings_modality is not None:
            
            _query_params.append(('meetings.modality', meetings_modality))
            
        if meetings_location_building is not None:
            
            _query_params.append(('meetings.location.building', meetings_location_building))
            
        if meetings_location_room is not None:
            
            _query_params.append(('meetings.location.room', meetings_location_room))
            
        if meetings_location_map_uri is not None:
            
            _query_params.append(('meetings.location.map_uri', meetings_location_map_uri))
            
        if core_flags is not None:
            
            _query_params.append(('core_flags', core_flags))
            
        if syllabus_uri is not None:
            
            _query_params.append(('syllabus_uri', syllabus_uri))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/section',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def swagger(
        self,
        file: Annotated[StrictStr, Field(description="The swagger file to retrieve")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """swagger

        Returns the OpenAPI/swagger spec for the API

        :param file: The swagger file to retrieve (required)
        :type file: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._swagger_serialize(
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def swagger_with_http_info(
        self,
        file: Annotated[StrictStr, Field(description="The swagger file to retrieve")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """swagger

        Returns the OpenAPI/swagger spec for the API

        :param file: The swagger file to retrieve (required)
        :type file: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._swagger_serialize(
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def swagger_without_preload_content(
        self,
        file: Annotated[StrictStr, Field(description="The swagger file to retrieve")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """swagger

        Returns the OpenAPI/swagger spec for the API

        :param file: The swagger file to retrieve (required)
        :type file: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._swagger_serialize(
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _swagger_serialize(
        self,
        file,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if file is not None:
            _path_params['file'] = file
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/swagger/{file}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def trends_course_section_search(
        self,
        course_number: Annotated[StrictStr, Field(description="The course's official number")],
        subject_prefix: Annotated[StrictStr, Field(description="The course's subject prefix")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseArraySchemaSection:
        """trends_course_section_search

        \"Returns all of the given course's sections. Specialized high-speed convenience endpoint for UTD Trends internal use; limited query flexibility.\"

        :param course_number: The course's official number (required)
        :type course_number: str
        :param subject_prefix: The course's subject prefix (required)
        :type subject_prefix: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trends_course_section_search_serialize(
            course_number=course_number,
            subject_prefix=subject_prefix,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaSection",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def trends_course_section_search_with_http_info(
        self,
        course_number: Annotated[StrictStr, Field(description="The course's official number")],
        subject_prefix: Annotated[StrictStr, Field(description="The course's subject prefix")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseArraySchemaSection]:
        """trends_course_section_search

        \"Returns all of the given course's sections. Specialized high-speed convenience endpoint for UTD Trends internal use; limited query flexibility.\"

        :param course_number: The course's official number (required)
        :type course_number: str
        :param subject_prefix: The course's subject prefix (required)
        :type subject_prefix: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trends_course_section_search_serialize(
            course_number=course_number,
            subject_prefix=subject_prefix,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaSection",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def trends_course_section_search_without_preload_content(
        self,
        course_number: Annotated[StrictStr, Field(description="The course's official number")],
        subject_prefix: Annotated[StrictStr, Field(description="The course's subject prefix")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """trends_course_section_search

        \"Returns all of the given course's sections. Specialized high-speed convenience endpoint for UTD Trends internal use; limited query flexibility.\"

        :param course_number: The course's official number (required)
        :type course_number: str
        :param subject_prefix: The course's subject prefix (required)
        :type subject_prefix: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trends_course_section_search_serialize(
            course_number=course_number,
            subject_prefix=subject_prefix,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaSection",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _trends_course_section_search_serialize(
        self,
        course_number,
        subject_prefix,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if course_number is not None:
            
            _query_params.append(('course_number', course_number))
            
        if subject_prefix is not None:
            
            _query_params.append(('subject_prefix', subject_prefix))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/course/sections/trends',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def trends_professor_section_search(
        self,
        first_name: Annotated[StrictStr, Field(description="The professor's first name")],
        last_name: Annotated[StrictStr, Field(description="The professor's last name")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SchemaAPIResponseArraySchemaSection:
        """trends_professor_section_search

        \"Returns all of the given professor's sections. Specialized high-speed convenience endpoint for UTD Trends internal use; limited query flexibility.\"

        :param first_name: The professor's first name (required)
        :type first_name: str
        :param last_name: The professor's last name (required)
        :type last_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trends_professor_section_search_serialize(
            first_name=first_name,
            last_name=last_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaSection",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def trends_professor_section_search_with_http_info(
        self,
        first_name: Annotated[StrictStr, Field(description="The professor's first name")],
        last_name: Annotated[StrictStr, Field(description="The professor's last name")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SchemaAPIResponseArraySchemaSection]:
        """trends_professor_section_search

        \"Returns all of the given professor's sections. Specialized high-speed convenience endpoint for UTD Trends internal use; limited query flexibility.\"

        :param first_name: The professor's first name (required)
        :type first_name: str
        :param last_name: The professor's last name (required)
        :type last_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trends_professor_section_search_serialize(
            first_name=first_name,
            last_name=last_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaSection",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def trends_professor_section_search_without_preload_content(
        self,
        first_name: Annotated[StrictStr, Field(description="The professor's first name")],
        last_name: Annotated[StrictStr, Field(description="The professor's last name")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """trends_professor_section_search

        \"Returns all of the given professor's sections. Specialized high-speed convenience endpoint for UTD Trends internal use; limited query flexibility.\"

        :param first_name: The professor's first name (required)
        :type first_name: str
        :param last_name: The professor's last name (required)
        :type last_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trends_professor_section_search_serialize(
            first_name=first_name,
            last_name=last_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SchemaAPIResponseArraySchemaSection",
            '500': "SchemaAPIResponseString",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _trends_professor_section_search_serialize(
        self,
        first_name,
        last_name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if first_name is not None:
            
            _query_params.append(('first_name', first_name))
            
        if last_name is not None:
            
            _query_params.append(('last_name', last_name))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/professor/sections/trends',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


